// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `connect.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:spotify.connectstate.ClusterUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClusterUpdate {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.ClusterUpdate.cluster)
    pub cluster: ::protobuf::MessageField<Cluster>,
    // @@protoc_insertion_point(field:spotify.connectstate.ClusterUpdate.update_reason)
    pub update_reason: ::protobuf::EnumOrUnknown<ClusterUpdateReason>,
    // @@protoc_insertion_point(field:spotify.connectstate.ClusterUpdate.ack_id)
    pub ack_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.ClusterUpdate.devices_that_changed)
    pub devices_that_changed: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.ClusterUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClusterUpdate {
    fn default() -> &'a ClusterUpdate {
        <ClusterUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ClusterUpdate {
    pub fn new() -> ClusterUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Cluster>(
            "cluster",
            |m: &ClusterUpdate| { &m.cluster },
            |m: &mut ClusterUpdate| { &mut m.cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "update_reason",
            |m: &ClusterUpdate| { &m.update_reason },
            |m: &mut ClusterUpdate| { &mut m.update_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ack_id",
            |m: &ClusterUpdate| { &m.ack_id },
            |m: &mut ClusterUpdate| { &mut m.ack_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "devices_that_changed",
            |m: &ClusterUpdate| { &m.devices_that_changed },
            |m: &mut ClusterUpdate| { &mut m.devices_that_changed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClusterUpdate>(
            "ClusterUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClusterUpdate {
    const NAME: &'static str = "ClusterUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cluster)?;
                },
                16 => {
                    self.update_reason = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.ack_id = is.read_string()?;
                },
                34 => {
                    self.devices_that_changed.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cluster.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.update_reason != ::protobuf::EnumOrUnknown::new(ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON) {
            my_size += ::protobuf::rt::int32_size(2, self.update_reason.value());
        }
        if !self.ack_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ack_id);
        }
        for value in &self.devices_that_changed {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cluster.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.update_reason != ::protobuf::EnumOrUnknown::new(ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.update_reason))?;
        }
        if !self.ack_id.is_empty() {
            os.write_string(3, &self.ack_id)?;
        }
        for v in &self.devices_that_changed {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClusterUpdate {
        ClusterUpdate::new()
    }

    fn clear(&mut self) {
        self.cluster.clear();
        self.update_reason = ::protobuf::EnumOrUnknown::new(ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON);
        self.ack_id.clear();
        self.devices_that_changed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClusterUpdate {
        static instance: ClusterUpdate = ClusterUpdate {
            cluster: ::protobuf::MessageField::none(),
            update_reason: ::protobuf::EnumOrUnknown::from_i32(0),
            ack_id: ::std::string::String::new(),
            devices_that_changed: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClusterUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClusterUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClusterUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.PostCommandResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PostCommandResponse {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.PostCommandResponse.ack_id)
    pub ack_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.PostCommandResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PostCommandResponse {
    fn default() -> &'a PostCommandResponse {
        <PostCommandResponse as ::protobuf::Message>::default_instance()
    }
}

impl PostCommandResponse {
    pub fn new() -> PostCommandResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ack_id",
            |m: &PostCommandResponse| { &m.ack_id },
            |m: &mut PostCommandResponse| { &mut m.ack_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PostCommandResponse>(
            "PostCommandResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PostCommandResponse {
    const NAME: &'static str = "PostCommandResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ack_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.ack_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ack_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.ack_id.is_empty() {
            os.write_string(1, &self.ack_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PostCommandResponse {
        PostCommandResponse::new()
    }

    fn clear(&mut self) {
        self.ack_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PostCommandResponse {
        static instance: PostCommandResponse = PostCommandResponse {
            ack_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PostCommandResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PostCommandResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PostCommandResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostCommandResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.Device)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Device {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.Device.device_info)
    pub device_info: ::protobuf::MessageField<DeviceInfo>,
    // @@protoc_insertion_point(field:spotify.connectstate.Device.player_state)
    pub player_state: ::protobuf::MessageField<super::player::PlayerState>,
    // @@protoc_insertion_point(field:spotify.connectstate.Device.private_device_info)
    pub private_device_info: ::protobuf::MessageField<PrivateDeviceInfo>,
    // @@protoc_insertion_point(field:spotify.connectstate.Device.transfer_data)
    pub transfer_data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.Device.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceInfo>(
            "device_info",
            |m: &Device| { &m.device_info },
            |m: &mut Device| { &mut m.device_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::player::PlayerState>(
            "player_state",
            |m: &Device| { &m.player_state },
            |m: &mut Device| { &mut m.player_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PrivateDeviceInfo>(
            "private_device_info",
            |m: &Device| { &m.private_device_info },
            |m: &mut Device| { &mut m.private_device_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transfer_data",
            |m: &Device| { &m.transfer_data },
            |m: &mut Device| { &mut m.transfer_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Device>(
            "Device",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Device {
    const NAME: &'static str = "Device";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.device_info)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_state)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.private_device_info)?;
                },
                34 => {
                    self.transfer_data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.private_device_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.transfer_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.transfer_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.device_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.player_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.private_device_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.transfer_data.is_empty() {
            os.write_bytes(4, &self.transfer_data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Device {
        Device::new()
    }

    fn clear(&mut self) {
        self.device_info.clear();
        self.player_state.clear();
        self.private_device_info.clear();
        self.transfer_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Device {
        static instance: Device = Device {
            device_info: ::protobuf::MessageField::none(),
            player_state: ::protobuf::MessageField::none(),
            private_device_info: ::protobuf::MessageField::none(),
            transfer_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Device {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Device").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.Cluster)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Cluster {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.changed_timestamp_ms)
    pub changed_timestamp_ms: i64,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.active_device_id)
    pub active_device_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.player_state)
    pub player_state: ::protobuf::MessageField<super::player::PlayerState>,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.device)
    pub device: ::std::collections::HashMap<::std::string::String, DeviceInfo>,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.transfer_data)
    pub transfer_data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.transfer_data_timestamp)
    pub transfer_data_timestamp: u64,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.not_playing_since_timestamp)
    pub not_playing_since_timestamp: i64,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.need_full_player_state)
    pub need_full_player_state: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Cluster.server_timestamp_ms)
    pub server_timestamp_ms: i64,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.Cluster.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Cluster {
    fn default() -> &'a Cluster {
        <Cluster as ::protobuf::Message>::default_instance()
    }
}

impl Cluster {
    pub fn new() -> Cluster {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "changed_timestamp_ms",
            |m: &Cluster| { &m.changed_timestamp_ms },
            |m: &mut Cluster| { &mut m.changed_timestamp_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "active_device_id",
            |m: &Cluster| { &m.active_device_id },
            |m: &mut Cluster| { &mut m.active_device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::player::PlayerState>(
            "player_state",
            |m: &Cluster| { &m.player_state },
            |m: &mut Cluster| { &mut m.player_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "device",
            |m: &Cluster| { &m.device },
            |m: &mut Cluster| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transfer_data",
            |m: &Cluster| { &m.transfer_data },
            |m: &mut Cluster| { &mut m.transfer_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transfer_data_timestamp",
            |m: &Cluster| { &m.transfer_data_timestamp },
            |m: &mut Cluster| { &mut m.transfer_data_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "not_playing_since_timestamp",
            |m: &Cluster| { &m.not_playing_since_timestamp },
            |m: &mut Cluster| { &mut m.not_playing_since_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "need_full_player_state",
            |m: &Cluster| { &m.need_full_player_state },
            |m: &mut Cluster| { &mut m.need_full_player_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_timestamp_ms",
            |m: &Cluster| { &m.server_timestamp_ms },
            |m: &mut Cluster| { &mut m.server_timestamp_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cluster>(
            "Cluster",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Cluster {
    const NAME: &'static str = "Cluster";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.changed_timestamp_ms = is.read_int64()?;
                },
                18 => {
                    self.active_device_id = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.player_state)?;
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.device.insert(key, value);
                },
                42 => {
                    self.transfer_data = is.read_bytes()?;
                },
                48 => {
                    self.transfer_data_timestamp = is.read_uint64()?;
                },
                56 => {
                    self.not_playing_since_timestamp = is.read_int64()?;
                },
                64 => {
                    self.need_full_player_state = is.read_bool()?;
                },
                72 => {
                    self.server_timestamp_ms = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.changed_timestamp_ms != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.changed_timestamp_ms);
        }
        if !self.active_device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.active_device_id);
        }
        if let Some(v) = self.player_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.device {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.transfer_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.transfer_data);
        }
        if self.transfer_data_timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.transfer_data_timestamp);
        }
        if self.not_playing_since_timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(7, self.not_playing_since_timestamp);
        }
        if self.need_full_player_state != false {
            my_size += 1 + 1;
        }
        if self.server_timestamp_ms != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.server_timestamp_ms);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.changed_timestamp_ms != 0 {
            os.write_int64(1, self.changed_timestamp_ms)?;
        }
        if !self.active_device_id.is_empty() {
            os.write_string(2, &self.active_device_id)?;
        }
        if let Some(v) = self.player_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for (k, v) in &self.device {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.transfer_data.is_empty() {
            os.write_bytes(5, &self.transfer_data)?;
        }
        if self.transfer_data_timestamp != 0 {
            os.write_uint64(6, self.transfer_data_timestamp)?;
        }
        if self.not_playing_since_timestamp != 0 {
            os.write_int64(7, self.not_playing_since_timestamp)?;
        }
        if self.need_full_player_state != false {
            os.write_bool(8, self.need_full_player_state)?;
        }
        if self.server_timestamp_ms != 0 {
            os.write_int64(9, self.server_timestamp_ms)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Cluster {
        Cluster::new()
    }

    fn clear(&mut self) {
        self.changed_timestamp_ms = 0;
        self.active_device_id.clear();
        self.player_state.clear();
        self.device.clear();
        self.transfer_data.clear();
        self.transfer_data_timestamp = 0;
        self.not_playing_since_timestamp = 0;
        self.need_full_player_state = false;
        self.server_timestamp_ms = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Cluster {
        static instance: ::protobuf::rt::Lazy<Cluster> = ::protobuf::rt::Lazy::new();
        instance.get(Cluster::new)
    }
}

impl ::protobuf::MessageFull for Cluster {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Cluster").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Cluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cluster {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.PutStateRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PutStateRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.callback_url)
    pub callback_url: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.device)
    pub device: ::protobuf::MessageField<Device>,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.member_type)
    pub member_type: ::protobuf::EnumOrUnknown<MemberType>,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.is_active)
    pub is_active: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.put_state_reason)
    pub put_state_reason: ::protobuf::EnumOrUnknown<PutStateReason>,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.message_id)
    pub message_id: u32,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.last_command_sent_by_device_id)
    pub last_command_sent_by_device_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.last_command_message_id)
    pub last_command_message_id: u32,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.started_playing_at)
    pub started_playing_at: u64,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.has_been_playing_for_ms)
    pub has_been_playing_for_ms: u64,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.client_side_timestamp)
    pub client_side_timestamp: u64,
    // @@protoc_insertion_point(field:spotify.connectstate.PutStateRequest.only_write_player_state)
    pub only_write_player_state: bool,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.PutStateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PutStateRequest {
    fn default() -> &'a PutStateRequest {
        <PutStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutStateRequest {
    pub fn new() -> PutStateRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "callback_url",
            |m: &PutStateRequest| { &m.callback_url },
            |m: &mut PutStateRequest| { &mut m.callback_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Device>(
            "device",
            |m: &PutStateRequest| { &m.device },
            |m: &mut PutStateRequest| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "member_type",
            |m: &PutStateRequest| { &m.member_type },
            |m: &mut PutStateRequest| { &mut m.member_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_active",
            |m: &PutStateRequest| { &m.is_active },
            |m: &mut PutStateRequest| { &mut m.is_active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "put_state_reason",
            |m: &PutStateRequest| { &m.put_state_reason },
            |m: &mut PutStateRequest| { &mut m.put_state_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &PutStateRequest| { &m.message_id },
            |m: &mut PutStateRequest| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_command_sent_by_device_id",
            |m: &PutStateRequest| { &m.last_command_sent_by_device_id },
            |m: &mut PutStateRequest| { &mut m.last_command_sent_by_device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_command_message_id",
            |m: &PutStateRequest| { &m.last_command_message_id },
            |m: &mut PutStateRequest| { &mut m.last_command_message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "started_playing_at",
            |m: &PutStateRequest| { &m.started_playing_at },
            |m: &mut PutStateRequest| { &mut m.started_playing_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_been_playing_for_ms",
            |m: &PutStateRequest| { &m.has_been_playing_for_ms },
            |m: &mut PutStateRequest| { &mut m.has_been_playing_for_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_side_timestamp",
            |m: &PutStateRequest| { &m.client_side_timestamp },
            |m: &mut PutStateRequest| { &mut m.client_side_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "only_write_player_state",
            |m: &PutStateRequest| { &m.only_write_player_state },
            |m: &mut PutStateRequest| { &mut m.only_write_player_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PutStateRequest>(
            "PutStateRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PutStateRequest {
    const NAME: &'static str = "PutStateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.callback_url = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.device)?;
                },
                24 => {
                    self.member_type = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.is_active = is.read_bool()?;
                },
                40 => {
                    self.put_state_reason = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.message_id = is.read_uint32()?;
                },
                58 => {
                    self.last_command_sent_by_device_id = is.read_string()?;
                },
                64 => {
                    self.last_command_message_id = is.read_uint32()?;
                },
                72 => {
                    self.started_playing_at = is.read_uint64()?;
                },
                88 => {
                    self.has_been_playing_for_ms = is.read_uint64()?;
                },
                96 => {
                    self.client_side_timestamp = is.read_uint64()?;
                },
                104 => {
                    self.only_write_player_state = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.callback_url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.callback_url);
        }
        if let Some(v) = self.device.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.member_type != ::protobuf::EnumOrUnknown::new(MemberType::SPIRC_V2) {
            my_size += ::protobuf::rt::int32_size(3, self.member_type.value());
        }
        if self.is_active != false {
            my_size += 1 + 1;
        }
        if self.put_state_reason != ::protobuf::EnumOrUnknown::new(PutStateReason::UNKNOWN_PUT_STATE_REASON) {
            my_size += ::protobuf::rt::int32_size(5, self.put_state_reason.value());
        }
        if self.message_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.message_id);
        }
        if !self.last_command_sent_by_device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.last_command_sent_by_device_id);
        }
        if self.last_command_message_id != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.last_command_message_id);
        }
        if self.started_playing_at != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.started_playing_at);
        }
        if self.has_been_playing_for_ms != 0 {
            my_size += ::protobuf::rt::uint64_size(11, self.has_been_playing_for_ms);
        }
        if self.client_side_timestamp != 0 {
            my_size += ::protobuf::rt::uint64_size(12, self.client_side_timestamp);
        }
        if self.only_write_player_state != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.callback_url.is_empty() {
            os.write_string(1, &self.callback_url)?;
        }
        if let Some(v) = self.device.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.member_type != ::protobuf::EnumOrUnknown::new(MemberType::SPIRC_V2) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.member_type))?;
        }
        if self.is_active != false {
            os.write_bool(4, self.is_active)?;
        }
        if self.put_state_reason != ::protobuf::EnumOrUnknown::new(PutStateReason::UNKNOWN_PUT_STATE_REASON) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.put_state_reason))?;
        }
        if self.message_id != 0 {
            os.write_uint32(6, self.message_id)?;
        }
        if !self.last_command_sent_by_device_id.is_empty() {
            os.write_string(7, &self.last_command_sent_by_device_id)?;
        }
        if self.last_command_message_id != 0 {
            os.write_uint32(8, self.last_command_message_id)?;
        }
        if self.started_playing_at != 0 {
            os.write_uint64(9, self.started_playing_at)?;
        }
        if self.has_been_playing_for_ms != 0 {
            os.write_uint64(11, self.has_been_playing_for_ms)?;
        }
        if self.client_side_timestamp != 0 {
            os.write_uint64(12, self.client_side_timestamp)?;
        }
        if self.only_write_player_state != false {
            os.write_bool(13, self.only_write_player_state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PutStateRequest {
        PutStateRequest::new()
    }

    fn clear(&mut self) {
        self.callback_url.clear();
        self.device.clear();
        self.member_type = ::protobuf::EnumOrUnknown::new(MemberType::SPIRC_V2);
        self.is_active = false;
        self.put_state_reason = ::protobuf::EnumOrUnknown::new(PutStateReason::UNKNOWN_PUT_STATE_REASON);
        self.message_id = 0;
        self.last_command_sent_by_device_id.clear();
        self.last_command_message_id = 0;
        self.started_playing_at = 0;
        self.has_been_playing_for_ms = 0;
        self.client_side_timestamp = 0;
        self.only_write_player_state = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PutStateRequest {
        static instance: PutStateRequest = PutStateRequest {
            callback_url: ::std::string::String::new(),
            device: ::protobuf::MessageField::none(),
            member_type: ::protobuf::EnumOrUnknown::from_i32(0),
            is_active: false,
            put_state_reason: ::protobuf::EnumOrUnknown::from_i32(0),
            message_id: 0,
            last_command_sent_by_device_id: ::std::string::String::new(),
            last_command_message_id: 0,
            started_playing_at: 0,
            has_been_playing_for_ms: 0,
            client_side_timestamp: 0,
            only_write_player_state: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PutStateRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PutStateRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PutStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutStateRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.PrivateDeviceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrivateDeviceInfo {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.PrivateDeviceInfo.platform)
    pub platform: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.PrivateDeviceInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrivateDeviceInfo {
    fn default() -> &'a PrivateDeviceInfo {
        <PrivateDeviceInfo as ::protobuf::Message>::default_instance()
    }
}

impl PrivateDeviceInfo {
    pub fn new() -> PrivateDeviceInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "platform",
            |m: &PrivateDeviceInfo| { &m.platform },
            |m: &mut PrivateDeviceInfo| { &mut m.platform },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PrivateDeviceInfo>(
            "PrivateDeviceInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PrivateDeviceInfo {
    const NAME: &'static str = "PrivateDeviceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.platform = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.platform.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.platform);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.platform.is_empty() {
            os.write_string(1, &self.platform)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrivateDeviceInfo {
        PrivateDeviceInfo::new()
    }

    fn clear(&mut self) {
        self.platform.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrivateDeviceInfo {
        static instance: PrivateDeviceInfo = PrivateDeviceInfo {
            platform: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PrivateDeviceInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PrivateDeviceInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PrivateDeviceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrivateDeviceInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.SubscribeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubscribeRequest {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.SubscribeRequest.callback_url)
    pub callback_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.SubscribeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeRequest {
    fn default() -> &'a SubscribeRequest {
        <SubscribeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeRequest {
    pub fn new() -> SubscribeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "callback_url",
            |m: &SubscribeRequest| { &m.callback_url },
            |m: &mut SubscribeRequest| { &mut m.callback_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeRequest>(
            "SubscribeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeRequest {
    const NAME: &'static str = "SubscribeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.callback_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.callback_url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.callback_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.callback_url.is_empty() {
            os.write_string(1, &self.callback_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeRequest {
        SubscribeRequest::new()
    }

    fn clear(&mut self) {
        self.callback_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeRequest {
        static instance: SubscribeRequest = SubscribeRequest {
            callback_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.DeviceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceInfo {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.can_play)
    pub can_play: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.volume)
    pub volume: u32,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.capabilities)
    pub capabilities: ::protobuf::MessageField<Capabilities>,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.metadata)
    pub metadata: ::std::vec::Vec<DeviceMetadata>,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.device_software_version)
    pub device_software_version: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.device_type)
    pub device_type: ::protobuf::EnumOrUnknown<super::devices::DeviceType>,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.spirc_version)
    pub spirc_version: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.device_id)
    pub device_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.is_private_session)
    pub is_private_session: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.is_social_connect)
    pub is_social_connect: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.client_id)
    pub client_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.brand)
    pub brand: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.model)
    pub model: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.metadata_map)
    pub metadata_map: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.product_id)
    pub product_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.deduplication_id)
    pub deduplication_id: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.selected_alias_id)
    pub selected_alias_id: u32,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.device_aliases)
    pub device_aliases: ::std::collections::HashMap<u32, super::devices::DeviceAlias>,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.is_offline)
    pub is_offline: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.public_ip)
    pub public_ip: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.license)
    pub license: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.is_group)
    pub is_group: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.is_dynamic_device)
    pub is_dynamic_device: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.disallow_playback_reasons)
    pub disallow_playback_reasons: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceInfo.disallow_transfer_reasons)
    pub disallow_transfer_reasons: ::std::vec::Vec<::std::string::String>,
    // message oneof groups
    pub _audio_output_device_info: ::std::option::Option<device_info::_audio_output_device_info>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.DeviceInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceInfo {
    fn default() -> &'a DeviceInfo {
        <DeviceInfo as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInfo {
    pub fn new() -> DeviceInfo {
        ::std::default::Default::default()
    }

    // .spotify.connectstate.AudioOutputDeviceInfo audio_output_device_info = 24;

    pub fn audio_output_device_info(&self) -> &AudioOutputDeviceInfo {
        match self._audio_output_device_info {
            ::std::option::Option::Some(device_info::_audio_output_device_info::AudioOutputDeviceInfo(ref v)) => v,
            _ => <AudioOutputDeviceInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_audio_output_device_info(&mut self) {
        self._audio_output_device_info = ::std::option::Option::None;
    }

    pub fn has_audio_output_device_info(&self) -> bool {
        match self._audio_output_device_info {
            ::std::option::Option::Some(device_info::_audio_output_device_info::AudioOutputDeviceInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio_output_device_info(&mut self, v: AudioOutputDeviceInfo) {
        self._audio_output_device_info = ::std::option::Option::Some(device_info::_audio_output_device_info::AudioOutputDeviceInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audio_output_device_info(&mut self) -> &mut AudioOutputDeviceInfo {
        if let ::std::option::Option::Some(device_info::_audio_output_device_info::AudioOutputDeviceInfo(_)) = self._audio_output_device_info {
        } else {
            self._audio_output_device_info = ::std::option::Option::Some(device_info::_audio_output_device_info::AudioOutputDeviceInfo(AudioOutputDeviceInfo::new()));
        }
        match self._audio_output_device_info {
            ::std::option::Option::Some(device_info::_audio_output_device_info::AudioOutputDeviceInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audio_output_device_info(&mut self) -> AudioOutputDeviceInfo {
        if self.has_audio_output_device_info() {
            match self._audio_output_device_info.take() {
                ::std::option::Option::Some(device_info::_audio_output_device_info::AudioOutputDeviceInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            AudioOutputDeviceInfo::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(27);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "can_play",
            |m: &DeviceInfo| { &m.can_play },
            |m: &mut DeviceInfo| { &mut m.can_play },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume",
            |m: &DeviceInfo| { &m.volume },
            |m: &mut DeviceInfo| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DeviceInfo| { &m.name },
            |m: &mut DeviceInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Capabilities>(
            "capabilities",
            |m: &DeviceInfo| { &m.capabilities },
            |m: &mut DeviceInfo| { &mut m.capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metadata",
            |m: &DeviceInfo| { &m.metadata },
            |m: &mut DeviceInfo| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_software_version",
            |m: &DeviceInfo| { &m.device_software_version },
            |m: &mut DeviceInfo| { &mut m.device_software_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_type",
            |m: &DeviceInfo| { &m.device_type },
            |m: &mut DeviceInfo| { &mut m.device_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "spirc_version",
            |m: &DeviceInfo| { &m.spirc_version },
            |m: &mut DeviceInfo| { &mut m.spirc_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &DeviceInfo| { &m.device_id },
            |m: &mut DeviceInfo| { &mut m.device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_private_session",
            |m: &DeviceInfo| { &m.is_private_session },
            |m: &mut DeviceInfo| { &mut m.is_private_session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_social_connect",
            |m: &DeviceInfo| { &m.is_social_connect },
            |m: &mut DeviceInfo| { &mut m.is_social_connect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &DeviceInfo| { &m.client_id },
            |m: &mut DeviceInfo| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "brand",
            |m: &DeviceInfo| { &m.brand },
            |m: &mut DeviceInfo| { &mut m.brand },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model",
            |m: &DeviceInfo| { &m.model },
            |m: &mut DeviceInfo| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "metadata_map",
            |m: &DeviceInfo| { &m.metadata_map },
            |m: &mut DeviceInfo| { &mut m.metadata_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_id",
            |m: &DeviceInfo| { &m.product_id },
            |m: &mut DeviceInfo| { &mut m.product_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deduplication_id",
            |m: &DeviceInfo| { &m.deduplication_id },
            |m: &mut DeviceInfo| { &mut m.deduplication_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "selected_alias_id",
            |m: &DeviceInfo| { &m.selected_alias_id },
            |m: &mut DeviceInfo| { &mut m.selected_alias_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "device_aliases",
            |m: &DeviceInfo| { &m.device_aliases },
            |m: &mut DeviceInfo| { &mut m.device_aliases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_offline",
            |m: &DeviceInfo| { &m.is_offline },
            |m: &mut DeviceInfo| { &mut m.is_offline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_ip",
            |m: &DeviceInfo| { &m.public_ip },
            |m: &mut DeviceInfo| { &mut m.public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "license",
            |m: &DeviceInfo| { &m.license },
            |m: &mut DeviceInfo| { &mut m.license },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_group",
            |m: &DeviceInfo| { &m.is_group },
            |m: &mut DeviceInfo| { &mut m.is_group },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_dynamic_device",
            |m: &DeviceInfo| { &m.is_dynamic_device },
            |m: &mut DeviceInfo| { &mut m.is_dynamic_device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "disallow_playback_reasons",
            |m: &DeviceInfo| { &m.disallow_playback_reasons },
            |m: &mut DeviceInfo| { &mut m.disallow_playback_reasons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "disallow_transfer_reasons",
            |m: &DeviceInfo| { &m.disallow_transfer_reasons },
            |m: &mut DeviceInfo| { &mut m.disallow_transfer_reasons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, AudioOutputDeviceInfo>(
            "audio_output_device_info",
            DeviceInfo::has_audio_output_device_info,
            DeviceInfo::audio_output_device_info,
            DeviceInfo::mut_audio_output_device_info,
            DeviceInfo::set_audio_output_device_info,
        ));
        oneofs.push(device_info::_audio_output_device_info::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceInfo>(
            "DeviceInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceInfo {
    const NAME: &'static str = "DeviceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.can_play = is.read_bool()?;
                },
                16 => {
                    self.volume = is.read_uint32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.capabilities)?;
                },
                42 => {
                    self.metadata.push(is.read_message()?);
                },
                50 => {
                    self.device_software_version = is.read_string()?;
                },
                56 => {
                    self.device_type = is.read_enum_or_unknown()?;
                },
                74 => {
                    self.spirc_version = is.read_string()?;
                },
                82 => {
                    self.device_id = is.read_string()?;
                },
                88 => {
                    self.is_private_session = is.read_bool()?;
                },
                96 => {
                    self.is_social_connect = is.read_bool()?;
                },
                106 => {
                    self.client_id = is.read_string()?;
                },
                114 => {
                    self.brand = is.read_string()?;
                },
                122 => {
                    self.model = is.read_string()?;
                },
                130 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata_map.insert(key, value);
                },
                138 => {
                    self.product_id = is.read_string()?;
                },
                146 => {
                    self.deduplication_id = is.read_string()?;
                },
                152 => {
                    self.selected_alias_id = is.read_uint32()?;
                },
                162 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.device_aliases.insert(key, value);
                },
                168 => {
                    self.is_offline = is.read_bool()?;
                },
                178 => {
                    self.public_ip = is.read_string()?;
                },
                186 => {
                    self.license = is.read_string()?;
                },
                200 => {
                    self.is_group = is.read_bool()?;
                },
                208 => {
                    self.is_dynamic_device = is.read_bool()?;
                },
                218 => {
                    self.disallow_playback_reasons.push(is.read_string()?);
                },
                226 => {
                    self.disallow_transfer_reasons.push(is.read_string()?);
                },
                194 => {
                    self._audio_output_device_info = ::std::option::Option::Some(device_info::_audio_output_device_info::AudioOutputDeviceInfo(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.can_play != false {
            my_size += 1 + 1;
        }
        if self.volume != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.volume);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if let Some(v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.device_software_version.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.device_software_version);
        }
        if self.device_type != ::protobuf::EnumOrUnknown::new(super::devices::DeviceType::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(7, self.device_type.value());
        }
        if !self.spirc_version.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.spirc_version);
        }
        if !self.device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.device_id);
        }
        if self.is_private_session != false {
            my_size += 1 + 1;
        }
        if self.is_social_connect != false {
            my_size += 1 + 1;
        }
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.client_id);
        }
        if !self.brand.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.brand);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.model);
        }
        for (k, v) in &self.metadata_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.product_id.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.product_id);
        }
        if !self.deduplication_id.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.deduplication_id);
        }
        if self.selected_alias_id != 0 {
            my_size += ::protobuf::rt::uint32_size(19, self.selected_alias_id);
        }
        for (k, v) in &self.device_aliases {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.is_offline != false {
            my_size += 2 + 1;
        }
        if !self.public_ip.is_empty() {
            my_size += ::protobuf::rt::string_size(22, &self.public_ip);
        }
        if !self.license.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.license);
        }
        if self.is_group != false {
            my_size += 2 + 1;
        }
        if self.is_dynamic_device != false {
            my_size += 2 + 1;
        }
        for value in &self.disallow_playback_reasons {
            my_size += ::protobuf::rt::string_size(27, &value);
        };
        for value in &self.disallow_transfer_reasons {
            my_size += ::protobuf::rt::string_size(28, &value);
        };
        if let ::std::option::Option::Some(ref v) = self._audio_output_device_info {
            match v {
                &device_info::_audio_output_device_info::AudioOutputDeviceInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.can_play != false {
            os.write_bool(1, self.can_play)?;
        }
        if self.volume != 0 {
            os.write_uint32(2, self.volume)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if let Some(v) = self.capabilities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.metadata {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if !self.device_software_version.is_empty() {
            os.write_string(6, &self.device_software_version)?;
        }
        if self.device_type != ::protobuf::EnumOrUnknown::new(super::devices::DeviceType::UNKNOWN) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.device_type))?;
        }
        if !self.spirc_version.is_empty() {
            os.write_string(9, &self.spirc_version)?;
        }
        if !self.device_id.is_empty() {
            os.write_string(10, &self.device_id)?;
        }
        if self.is_private_session != false {
            os.write_bool(11, self.is_private_session)?;
        }
        if self.is_social_connect != false {
            os.write_bool(12, self.is_social_connect)?;
        }
        if !self.client_id.is_empty() {
            os.write_string(13, &self.client_id)?;
        }
        if !self.brand.is_empty() {
            os.write_string(14, &self.brand)?;
        }
        if !self.model.is_empty() {
            os.write_string(15, &self.model)?;
        }
        for (k, v) in &self.metadata_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(130)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if !self.product_id.is_empty() {
            os.write_string(17, &self.product_id)?;
        }
        if !self.deduplication_id.is_empty() {
            os.write_string(18, &self.deduplication_id)?;
        }
        if self.selected_alias_id != 0 {
            os.write_uint32(19, self.selected_alias_id)?;
        }
        for (k, v) in &self.device_aliases {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(162)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.is_offline != false {
            os.write_bool(21, self.is_offline)?;
        }
        if !self.public_ip.is_empty() {
            os.write_string(22, &self.public_ip)?;
        }
        if !self.license.is_empty() {
            os.write_string(23, &self.license)?;
        }
        if self.is_group != false {
            os.write_bool(25, self.is_group)?;
        }
        if self.is_dynamic_device != false {
            os.write_bool(26, self.is_dynamic_device)?;
        }
        for v in &self.disallow_playback_reasons {
            os.write_string(27, &v)?;
        };
        for v in &self.disallow_transfer_reasons {
            os.write_string(28, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self._audio_output_device_info {
            match v {
                &device_info::_audio_output_device_info::AudioOutputDeviceInfo(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceInfo {
        DeviceInfo::new()
    }

    fn clear(&mut self) {
        self.can_play = false;
        self.volume = 0;
        self.name.clear();
        self.capabilities.clear();
        self.metadata.clear();
        self.device_software_version.clear();
        self.device_type = ::protobuf::EnumOrUnknown::new(super::devices::DeviceType::UNKNOWN);
        self.spirc_version.clear();
        self.device_id.clear();
        self.is_private_session = false;
        self.is_social_connect = false;
        self.client_id.clear();
        self.brand.clear();
        self.model.clear();
        self.metadata_map.clear();
        self.product_id.clear();
        self.deduplication_id.clear();
        self.selected_alias_id = 0;
        self.device_aliases.clear();
        self.is_offline = false;
        self.public_ip.clear();
        self.license.clear();
        self.is_group = false;
        self.is_dynamic_device = false;
        self.disallow_playback_reasons.clear();
        self.disallow_transfer_reasons.clear();
        self._audio_output_device_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceInfo {
        static instance: ::protobuf::rt::Lazy<DeviceInfo> = ::protobuf::rt::Lazy::new();
        instance.get(DeviceInfo::new)
    }
}

impl ::protobuf::MessageFull for DeviceInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DeviceInfo`
pub mod device_info {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.connectstate.DeviceInfo._audio_output_device_info)
    pub enum _audio_output_device_info {
        // @@protoc_insertion_point(oneof_field:spotify.connectstate.DeviceInfo.audio_output_device_info)
        AudioOutputDeviceInfo(super::AudioOutputDeviceInfo),
    }

    impl ::protobuf::Oneof for _audio_output_device_info {
    }

    impl ::protobuf::OneofFull for _audio_output_device_info {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::DeviceInfo as ::protobuf::MessageFull>::descriptor().oneof_by_name("_audio_output_device_info").unwrap()).clone()
        }
    }

    impl _audio_output_device_info {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<_audio_output_device_info>("_audio_output_device_info")
        }
    }
}

// @@protoc_insertion_point(message:spotify.connectstate.AudioOutputDeviceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AudioOutputDeviceInfo {
    // message oneof groups
    pub _audio_output_device_type: ::std::option::Option<audio_output_device_info::_audio_output_device_type>,
    pub _device_name: ::std::option::Option<audio_output_device_info::_device_name>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.AudioOutputDeviceInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AudioOutputDeviceInfo {
    fn default() -> &'a AudioOutputDeviceInfo {
        <AudioOutputDeviceInfo as ::protobuf::Message>::default_instance()
    }
}

impl AudioOutputDeviceInfo {
    pub fn new() -> AudioOutputDeviceInfo {
        ::std::default::Default::default()
    }

    // .spotify.connectstate.AudioOutputDeviceType audio_output_device_type = 1;

    pub fn audio_output_device_type(&self) -> AudioOutputDeviceType {
        match self._audio_output_device_type {
            ::std::option::Option::Some(audio_output_device_info::_audio_output_device_type::AudioOutputDeviceType(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => AudioOutputDeviceType::UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE,
        }
    }

    pub fn clear_audio_output_device_type(&mut self) {
        self._audio_output_device_type = ::std::option::Option::None;
    }

    pub fn has_audio_output_device_type(&self) -> bool {
        match self._audio_output_device_type {
            ::std::option::Option::Some(audio_output_device_info::_audio_output_device_type::AudioOutputDeviceType(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio_output_device_type(&mut self, v: AudioOutputDeviceType) {
        self._audio_output_device_type = ::std::option::Option::Some(audio_output_device_info::_audio_output_device_type::AudioOutputDeviceType(::protobuf::EnumOrUnknown::new(v)))
    }

    // string device_name = 2;

    pub fn device_name(&self) -> &str {
        match self._device_name {
            ::std::option::Option::Some(audio_output_device_info::_device_name::DeviceName(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_device_name(&mut self) {
        self._device_name = ::std::option::Option::None;
    }

    pub fn has_device_name(&self) -> bool {
        match self._device_name {
            ::std::option::Option::Some(audio_output_device_info::_device_name::DeviceName(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self._device_name = ::std::option::Option::Some(audio_output_device_info::_device_name::DeviceName(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(audio_output_device_info::_device_name::DeviceName(_)) = self._device_name {
        } else {
            self._device_name = ::std::option::Option::Some(audio_output_device_info::_device_name::DeviceName(::std::string::String::new()));
        }
        match self._device_name {
            ::std::option::Option::Some(audio_output_device_info::_device_name::DeviceName(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        if self.has_device_name() {
            match self._device_name.take() {
                ::std::option::Option::Some(audio_output_device_info::_device_name::DeviceName(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(2);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "audio_output_device_type",
            |message: &AudioOutputDeviceInfo| match &message._audio_output_device_type {
                ::std::option::Option::Some(audio_output_device_info::_audio_output_device_type::AudioOutputDeviceType(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut AudioOutputDeviceInfo, e: ::protobuf::EnumOrUnknown<AudioOutputDeviceType>| {
                message._audio_output_device_type = ::std::option::Option::Some(audio_output_device_info::_audio_output_device_type::AudioOutputDeviceType(e));
            },
            AudioOutputDeviceType::UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "device_name",
            AudioOutputDeviceInfo::has_device_name,
            AudioOutputDeviceInfo::device_name,
            AudioOutputDeviceInfo::set_device_name,
        ));
        oneofs.push(audio_output_device_info::_audio_output_device_type::generated_oneof_descriptor_data());
        oneofs.push(audio_output_device_info::_device_name::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AudioOutputDeviceInfo>(
            "AudioOutputDeviceInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AudioOutputDeviceInfo {
    const NAME: &'static str = "AudioOutputDeviceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self._audio_output_device_type = ::std::option::Option::Some(audio_output_device_info::_audio_output_device_type::AudioOutputDeviceType(is.read_enum_or_unknown()?));
                },
                18 => {
                    self._device_name = ::std::option::Option::Some(audio_output_device_info::_device_name::DeviceName(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self._audio_output_device_type {
            match v {
                &audio_output_device_info::_audio_output_device_type::AudioOutputDeviceType(v) => {
                    my_size += ::protobuf::rt::int32_size(1, v.value());
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._device_name {
            match v {
                &audio_output_device_info::_device_name::DeviceName(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self._audio_output_device_type {
            match v {
                &audio_output_device_info::_audio_output_device_type::AudioOutputDeviceType(v) => {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self._device_name {
            match v {
                &audio_output_device_info::_device_name::DeviceName(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AudioOutputDeviceInfo {
        AudioOutputDeviceInfo::new()
    }

    fn clear(&mut self) {
        self._audio_output_device_type = ::std::option::Option::None;
        self._device_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AudioOutputDeviceInfo {
        static instance: AudioOutputDeviceInfo = AudioOutputDeviceInfo {
            _audio_output_device_type: ::std::option::Option::None,
            _device_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AudioOutputDeviceInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AudioOutputDeviceInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AudioOutputDeviceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AudioOutputDeviceInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AudioOutputDeviceInfo`
pub mod audio_output_device_info {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.connectstate.AudioOutputDeviceInfo._audio_output_device_type)
    pub enum _audio_output_device_type {
        // @@protoc_insertion_point(oneof_field:spotify.connectstate.AudioOutputDeviceInfo.audio_output_device_type)
        AudioOutputDeviceType(::protobuf::EnumOrUnknown<super::AudioOutputDeviceType>),
    }

    impl ::protobuf::Oneof for _audio_output_device_type {
    }

    impl ::protobuf::OneofFull for _audio_output_device_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::AudioOutputDeviceInfo as ::protobuf::MessageFull>::descriptor().oneof_by_name("_audio_output_device_type").unwrap()).clone()
        }
    }

    impl _audio_output_device_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<_audio_output_device_type>("_audio_output_device_type")
        }
    }

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:spotify.connectstate.AudioOutputDeviceInfo._device_name)
    pub enum _device_name {
        // @@protoc_insertion_point(oneof_field:spotify.connectstate.AudioOutputDeviceInfo.device_name)
        DeviceName(::std::string::String),
    }

    impl ::protobuf::Oneof for _device_name {
    }

    impl ::protobuf::OneofFull for _device_name {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::AudioOutputDeviceInfo as ::protobuf::MessageFull>::descriptor().oneof_by_name("_device_name").unwrap()).clone()
        }
    }

    impl _device_name {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<_device_name>("_device_name")
        }
    }
}

// @@protoc_insertion_point(message:spotify.connectstate.DeviceMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceMetadata {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceMetadata.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.DeviceMetadata.metadata)
    pub metadata: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.DeviceMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceMetadata {
    fn default() -> &'a DeviceMetadata {
        <DeviceMetadata as ::protobuf::Message>::default_instance()
    }
}

impl DeviceMetadata {
    pub fn new() -> DeviceMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &DeviceMetadata| { &m.type_ },
            |m: &mut DeviceMetadata| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metadata",
            |m: &DeviceMetadata| { &m.metadata },
            |m: &mut DeviceMetadata| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceMetadata>(
            "DeviceMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceMetadata {
    const NAME: &'static str = "DeviceMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = is.read_string()?;
                },
                18 => {
                    self.metadata = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(1, &self.type_)?;
        }
        if !self.metadata.is_empty() {
            os.write_string(2, &self.metadata)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceMetadata {
        DeviceMetadata::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceMetadata {
        static instance: DeviceMetadata = DeviceMetadata {
            type_: ::std::string::String::new(),
            metadata: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.Capabilities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Capabilities {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.can_be_player)
    pub can_be_player: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.restrict_to_local)
    pub restrict_to_local: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.gaia_eq_connect_id)
    pub gaia_eq_connect_id: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_logout)
    pub supports_logout: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.is_observable)
    pub is_observable: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.volume_steps)
    pub volume_steps: i32,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supported_types)
    pub supported_types: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.command_acks)
    pub command_acks: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_rename)
    pub supports_rename: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.hidden)
    pub hidden: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.disable_volume)
    pub disable_volume: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.connect_disabled)
    pub connect_disabled: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_playlist_v2)
    pub supports_playlist_v2: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.is_controllable)
    pub is_controllable: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_external_episodes)
    pub supports_external_episodes: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_set_backend_metadata)
    pub supports_set_backend_metadata: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_transfer_command)
    pub supports_transfer_command: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_command_request)
    pub supports_command_request: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.is_voice_enabled)
    pub is_voice_enabled: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.needs_full_player_state)
    pub needs_full_player_state: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_gzip_pushes)
    pub supports_gzip_pushes: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_set_options_command)
    pub supports_set_options_command: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.supports_hifi)
    pub supports_hifi: ::protobuf::MessageField<CapabilitySupportDetails>,
    // @@protoc_insertion_point(field:spotify.connectstate.Capabilities.connect_capabilities)
    pub connect_capabilities: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.Capabilities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Capabilities {
    fn default() -> &'a Capabilities {
        <Capabilities as ::protobuf::Message>::default_instance()
    }
}

impl Capabilities {
    pub fn new() -> Capabilities {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "can_be_player",
            |m: &Capabilities| { &m.can_be_player },
            |m: &mut Capabilities| { &mut m.can_be_player },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "restrict_to_local",
            |m: &Capabilities| { &m.restrict_to_local },
            |m: &mut Capabilities| { &mut m.restrict_to_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gaia_eq_connect_id",
            |m: &Capabilities| { &m.gaia_eq_connect_id },
            |m: &mut Capabilities| { &mut m.gaia_eq_connect_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_logout",
            |m: &Capabilities| { &m.supports_logout },
            |m: &mut Capabilities| { &mut m.supports_logout },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_observable",
            |m: &Capabilities| { &m.is_observable },
            |m: &mut Capabilities| { &mut m.is_observable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume_steps",
            |m: &Capabilities| { &m.volume_steps },
            |m: &mut Capabilities| { &mut m.volume_steps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_types",
            |m: &Capabilities| { &m.supported_types },
            |m: &mut Capabilities| { &mut m.supported_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "command_acks",
            |m: &Capabilities| { &m.command_acks },
            |m: &mut Capabilities| { &mut m.command_acks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_rename",
            |m: &Capabilities| { &m.supports_rename },
            |m: &mut Capabilities| { &mut m.supports_rename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hidden",
            |m: &Capabilities| { &m.hidden },
            |m: &mut Capabilities| { &mut m.hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disable_volume",
            |m: &Capabilities| { &m.disable_volume },
            |m: &mut Capabilities| { &mut m.disable_volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connect_disabled",
            |m: &Capabilities| { &m.connect_disabled },
            |m: &mut Capabilities| { &mut m.connect_disabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_playlist_v2",
            |m: &Capabilities| { &m.supports_playlist_v2 },
            |m: &mut Capabilities| { &mut m.supports_playlist_v2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_controllable",
            |m: &Capabilities| { &m.is_controllable },
            |m: &mut Capabilities| { &mut m.is_controllable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_external_episodes",
            |m: &Capabilities| { &m.supports_external_episodes },
            |m: &mut Capabilities| { &mut m.supports_external_episodes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_set_backend_metadata",
            |m: &Capabilities| { &m.supports_set_backend_metadata },
            |m: &mut Capabilities| { &mut m.supports_set_backend_metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_transfer_command",
            |m: &Capabilities| { &m.supports_transfer_command },
            |m: &mut Capabilities| { &mut m.supports_transfer_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_command_request",
            |m: &Capabilities| { &m.supports_command_request },
            |m: &mut Capabilities| { &mut m.supports_command_request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_voice_enabled",
            |m: &Capabilities| { &m.is_voice_enabled },
            |m: &mut Capabilities| { &mut m.is_voice_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "needs_full_player_state",
            |m: &Capabilities| { &m.needs_full_player_state },
            |m: &mut Capabilities| { &mut m.needs_full_player_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_gzip_pushes",
            |m: &Capabilities| { &m.supports_gzip_pushes },
            |m: &mut Capabilities| { &mut m.supports_gzip_pushes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_set_options_command",
            |m: &Capabilities| { &m.supports_set_options_command },
            |m: &mut Capabilities| { &mut m.supports_set_options_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CapabilitySupportDetails>(
            "supports_hifi",
            |m: &Capabilities| { &m.supports_hifi },
            |m: &mut Capabilities| { &mut m.supports_hifi },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connect_capabilities",
            |m: &Capabilities| { &m.connect_capabilities },
            |m: &mut Capabilities| { &mut m.connect_capabilities },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Capabilities>(
            "Capabilities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Capabilities {
    const NAME: &'static str = "Capabilities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.can_be_player = is.read_bool()?;
                },
                24 => {
                    self.restrict_to_local = is.read_bool()?;
                },
                40 => {
                    self.gaia_eq_connect_id = is.read_bool()?;
                },
                48 => {
                    self.supports_logout = is.read_bool()?;
                },
                56 => {
                    self.is_observable = is.read_bool()?;
                },
                64 => {
                    self.volume_steps = is.read_int32()?;
                },
                74 => {
                    self.supported_types.push(is.read_string()?);
                },
                80 => {
                    self.command_acks = is.read_bool()?;
                },
                88 => {
                    self.supports_rename = is.read_bool()?;
                },
                96 => {
                    self.hidden = is.read_bool()?;
                },
                104 => {
                    self.disable_volume = is.read_bool()?;
                },
                112 => {
                    self.connect_disabled = is.read_bool()?;
                },
                120 => {
                    self.supports_playlist_v2 = is.read_bool()?;
                },
                128 => {
                    self.is_controllable = is.read_bool()?;
                },
                136 => {
                    self.supports_external_episodes = is.read_bool()?;
                },
                144 => {
                    self.supports_set_backend_metadata = is.read_bool()?;
                },
                152 => {
                    self.supports_transfer_command = is.read_bool()?;
                },
                160 => {
                    self.supports_command_request = is.read_bool()?;
                },
                168 => {
                    self.is_voice_enabled = is.read_bool()?;
                },
                176 => {
                    self.needs_full_player_state = is.read_bool()?;
                },
                184 => {
                    self.supports_gzip_pushes = is.read_bool()?;
                },
                200 => {
                    self.supports_set_options_command = is.read_bool()?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.supports_hifi)?;
                },
                218 => {
                    self.connect_capabilities = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.can_be_player != false {
            my_size += 1 + 1;
        }
        if self.restrict_to_local != false {
            my_size += 1 + 1;
        }
        if self.gaia_eq_connect_id != false {
            my_size += 1 + 1;
        }
        if self.supports_logout != false {
            my_size += 1 + 1;
        }
        if self.is_observable != false {
            my_size += 1 + 1;
        }
        if self.volume_steps != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.volume_steps);
        }
        for value in &self.supported_types {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if self.command_acks != false {
            my_size += 1 + 1;
        }
        if self.supports_rename != false {
            my_size += 1 + 1;
        }
        if self.hidden != false {
            my_size += 1 + 1;
        }
        if self.disable_volume != false {
            my_size += 1 + 1;
        }
        if self.connect_disabled != false {
            my_size += 1 + 1;
        }
        if self.supports_playlist_v2 != false {
            my_size += 1 + 1;
        }
        if self.is_controllable != false {
            my_size += 2 + 1;
        }
        if self.supports_external_episodes != false {
            my_size += 2 + 1;
        }
        if self.supports_set_backend_metadata != false {
            my_size += 2 + 1;
        }
        if self.supports_transfer_command != false {
            my_size += 2 + 1;
        }
        if self.supports_command_request != false {
            my_size += 2 + 1;
        }
        if self.is_voice_enabled != false {
            my_size += 2 + 1;
        }
        if self.needs_full_player_state != false {
            my_size += 2 + 1;
        }
        if self.supports_gzip_pushes != false {
            my_size += 2 + 1;
        }
        if self.supports_set_options_command != false {
            my_size += 2 + 1;
        }
        if let Some(v) = self.supports_hifi.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.connect_capabilities.is_empty() {
            my_size += ::protobuf::rt::string_size(27, &self.connect_capabilities);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.can_be_player != false {
            os.write_bool(2, self.can_be_player)?;
        }
        if self.restrict_to_local != false {
            os.write_bool(3, self.restrict_to_local)?;
        }
        if self.gaia_eq_connect_id != false {
            os.write_bool(5, self.gaia_eq_connect_id)?;
        }
        if self.supports_logout != false {
            os.write_bool(6, self.supports_logout)?;
        }
        if self.is_observable != false {
            os.write_bool(7, self.is_observable)?;
        }
        if self.volume_steps != 0 {
            os.write_int32(8, self.volume_steps)?;
        }
        for v in &self.supported_types {
            os.write_string(9, &v)?;
        };
        if self.command_acks != false {
            os.write_bool(10, self.command_acks)?;
        }
        if self.supports_rename != false {
            os.write_bool(11, self.supports_rename)?;
        }
        if self.hidden != false {
            os.write_bool(12, self.hidden)?;
        }
        if self.disable_volume != false {
            os.write_bool(13, self.disable_volume)?;
        }
        if self.connect_disabled != false {
            os.write_bool(14, self.connect_disabled)?;
        }
        if self.supports_playlist_v2 != false {
            os.write_bool(15, self.supports_playlist_v2)?;
        }
        if self.is_controllable != false {
            os.write_bool(16, self.is_controllable)?;
        }
        if self.supports_external_episodes != false {
            os.write_bool(17, self.supports_external_episodes)?;
        }
        if self.supports_set_backend_metadata != false {
            os.write_bool(18, self.supports_set_backend_metadata)?;
        }
        if self.supports_transfer_command != false {
            os.write_bool(19, self.supports_transfer_command)?;
        }
        if self.supports_command_request != false {
            os.write_bool(20, self.supports_command_request)?;
        }
        if self.is_voice_enabled != false {
            os.write_bool(21, self.is_voice_enabled)?;
        }
        if self.needs_full_player_state != false {
            os.write_bool(22, self.needs_full_player_state)?;
        }
        if self.supports_gzip_pushes != false {
            os.write_bool(23, self.supports_gzip_pushes)?;
        }
        if self.supports_set_options_command != false {
            os.write_bool(25, self.supports_set_options_command)?;
        }
        if let Some(v) = self.supports_hifi.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if !self.connect_capabilities.is_empty() {
            os.write_string(27, &self.connect_capabilities)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Capabilities {
        Capabilities::new()
    }

    fn clear(&mut self) {
        self.can_be_player = false;
        self.restrict_to_local = false;
        self.gaia_eq_connect_id = false;
        self.supports_logout = false;
        self.is_observable = false;
        self.volume_steps = 0;
        self.supported_types.clear();
        self.command_acks = false;
        self.supports_rename = false;
        self.hidden = false;
        self.disable_volume = false;
        self.connect_disabled = false;
        self.supports_playlist_v2 = false;
        self.is_controllable = false;
        self.supports_external_episodes = false;
        self.supports_set_backend_metadata = false;
        self.supports_transfer_command = false;
        self.supports_command_request = false;
        self.is_voice_enabled = false;
        self.needs_full_player_state = false;
        self.supports_gzip_pushes = false;
        self.supports_set_options_command = false;
        self.supports_hifi.clear();
        self.connect_capabilities.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Capabilities {
        static instance: Capabilities = Capabilities {
            can_be_player: false,
            restrict_to_local: false,
            gaia_eq_connect_id: false,
            supports_logout: false,
            is_observable: false,
            volume_steps: 0,
            supported_types: ::std::vec::Vec::new(),
            command_acks: false,
            supports_rename: false,
            hidden: false,
            disable_volume: false,
            connect_disabled: false,
            supports_playlist_v2: false,
            is_controllable: false,
            supports_external_episodes: false,
            supports_set_backend_metadata: false,
            supports_transfer_command: false,
            supports_command_request: false,
            is_voice_enabled: false,
            needs_full_player_state: false,
            supports_gzip_pushes: false,
            supports_set_options_command: false,
            supports_hifi: ::protobuf::MessageField::none(),
            connect_capabilities: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Capabilities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Capabilities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Capabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Capabilities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.CapabilitySupportDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CapabilitySupportDetails {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.CapabilitySupportDetails.fully_supported)
    pub fully_supported: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.CapabilitySupportDetails.user_eligible)
    pub user_eligible: bool,
    // @@protoc_insertion_point(field:spotify.connectstate.CapabilitySupportDetails.device_supported)
    pub device_supported: bool,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.CapabilitySupportDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CapabilitySupportDetails {
    fn default() -> &'a CapabilitySupportDetails {
        <CapabilitySupportDetails as ::protobuf::Message>::default_instance()
    }
}

impl CapabilitySupportDetails {
    pub fn new() -> CapabilitySupportDetails {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fully_supported",
            |m: &CapabilitySupportDetails| { &m.fully_supported },
            |m: &mut CapabilitySupportDetails| { &mut m.fully_supported },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_eligible",
            |m: &CapabilitySupportDetails| { &m.user_eligible },
            |m: &mut CapabilitySupportDetails| { &mut m.user_eligible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_supported",
            |m: &CapabilitySupportDetails| { &m.device_supported },
            |m: &mut CapabilitySupportDetails| { &mut m.device_supported },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CapabilitySupportDetails>(
            "CapabilitySupportDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CapabilitySupportDetails {
    const NAME: &'static str = "CapabilitySupportDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fully_supported = is.read_bool()?;
                },
                16 => {
                    self.user_eligible = is.read_bool()?;
                },
                24 => {
                    self.device_supported = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fully_supported != false {
            my_size += 1 + 1;
        }
        if self.user_eligible != false {
            my_size += 1 + 1;
        }
        if self.device_supported != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fully_supported != false {
            os.write_bool(1, self.fully_supported)?;
        }
        if self.user_eligible != false {
            os.write_bool(2, self.user_eligible)?;
        }
        if self.device_supported != false {
            os.write_bool(3, self.device_supported)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CapabilitySupportDetails {
        CapabilitySupportDetails::new()
    }

    fn clear(&mut self) {
        self.fully_supported = false;
        self.user_eligible = false;
        self.device_supported = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CapabilitySupportDetails {
        static instance: CapabilitySupportDetails = CapabilitySupportDetails {
            fully_supported: false,
            user_eligible: false,
            device_supported: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CapabilitySupportDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CapabilitySupportDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CapabilitySupportDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapabilitySupportDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.ConnectCommandOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectCommandOptions {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.ConnectCommandOptions.message_id)
    pub message_id: i32,
    // @@protoc_insertion_point(field:spotify.connectstate.ConnectCommandOptions.target_alias_id)
    pub target_alias_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.ConnectCommandOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectCommandOptions {
    fn default() -> &'a ConnectCommandOptions {
        <ConnectCommandOptions as ::protobuf::Message>::default_instance()
    }
}

impl ConnectCommandOptions {
    pub fn new() -> ConnectCommandOptions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message_id",
            |m: &ConnectCommandOptions| { &m.message_id },
            |m: &mut ConnectCommandOptions| { &mut m.message_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_alias_id",
            |m: &ConnectCommandOptions| { &m.target_alias_id },
            |m: &mut ConnectCommandOptions| { &mut m.target_alias_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectCommandOptions>(
            "ConnectCommandOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectCommandOptions {
    const NAME: &'static str = "ConnectCommandOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_id = is.read_int32()?;
                },
                24 => {
                    self.target_alias_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.message_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.message_id);
        }
        if self.target_alias_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.target_alias_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.message_id != 0 {
            os.write_int32(1, self.message_id)?;
        }
        if self.target_alias_id != 0 {
            os.write_uint32(3, self.target_alias_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectCommandOptions {
        ConnectCommandOptions::new()
    }

    fn clear(&mut self) {
        self.message_id = 0;
        self.target_alias_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectCommandOptions {
        static instance: ConnectCommandOptions = ConnectCommandOptions {
            message_id: 0,
            target_alias_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectCommandOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectCommandOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectCommandOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectCommandOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.LogoutCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogoutCommand {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.LogoutCommand.command_options)
    pub command_options: ::protobuf::MessageField<ConnectCommandOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.LogoutCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogoutCommand {
    fn default() -> &'a LogoutCommand {
        <LogoutCommand as ::protobuf::Message>::default_instance()
    }
}

impl LogoutCommand {
    pub fn new() -> LogoutCommand {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectCommandOptions>(
            "command_options",
            |m: &LogoutCommand| { &m.command_options },
            |m: &mut LogoutCommand| { &mut m.command_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogoutCommand>(
            "LogoutCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogoutCommand {
    const NAME: &'static str = "LogoutCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.command_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.command_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogoutCommand {
        LogoutCommand::new()
    }

    fn clear(&mut self) {
        self.command_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogoutCommand {
        static instance: LogoutCommand = LogoutCommand {
            command_options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogoutCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogoutCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogoutCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogoutCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.SetVolumeCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetVolumeCommand {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.SetVolumeCommand.volume)
    pub volume: i32,
    // @@protoc_insertion_point(field:spotify.connectstate.SetVolumeCommand.command_options)
    pub command_options: ::protobuf::MessageField<ConnectCommandOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.SetVolumeCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetVolumeCommand {
    fn default() -> &'a SetVolumeCommand {
        <SetVolumeCommand as ::protobuf::Message>::default_instance()
    }
}

impl SetVolumeCommand {
    pub fn new() -> SetVolumeCommand {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume",
            |m: &SetVolumeCommand| { &m.volume },
            |m: &mut SetVolumeCommand| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectCommandOptions>(
            "command_options",
            |m: &SetVolumeCommand| { &m.command_options },
            |m: &mut SetVolumeCommand| { &mut m.command_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetVolumeCommand>(
            "SetVolumeCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetVolumeCommand {
    const NAME: &'static str = "SetVolumeCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.volume = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.command_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.volume != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.volume);
        }
        if let Some(v) = self.command_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.volume != 0 {
            os.write_int32(1, self.volume)?;
        }
        if let Some(v) = self.command_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetVolumeCommand {
        SetVolumeCommand::new()
    }

    fn clear(&mut self) {
        self.volume = 0;
        self.command_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetVolumeCommand {
        static instance: SetVolumeCommand = SetVolumeCommand {
            volume: 0,
            command_options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetVolumeCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetVolumeCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetVolumeCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetVolumeCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.RenameCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RenameCommand {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.RenameCommand.rename_to)
    pub rename_to: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.RenameCommand.command_options)
    pub command_options: ::protobuf::MessageField<ConnectCommandOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.RenameCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RenameCommand {
    fn default() -> &'a RenameCommand {
        <RenameCommand as ::protobuf::Message>::default_instance()
    }
}

impl RenameCommand {
    pub fn new() -> RenameCommand {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rename_to",
            |m: &RenameCommand| { &m.rename_to },
            |m: &mut RenameCommand| { &mut m.rename_to },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectCommandOptions>(
            "command_options",
            |m: &RenameCommand| { &m.command_options },
            |m: &mut RenameCommand| { &mut m.command_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RenameCommand>(
            "RenameCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RenameCommand {
    const NAME: &'static str = "RenameCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rename_to = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.command_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.rename_to.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rename_to);
        }
        if let Some(v) = self.command_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.rename_to.is_empty() {
            os.write_string(1, &self.rename_to)?;
        }
        if let Some(v) = self.command_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RenameCommand {
        RenameCommand::new()
    }

    fn clear(&mut self) {
        self.rename_to.clear();
        self.command_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RenameCommand {
        static instance: RenameCommand = RenameCommand {
            rename_to: ::std::string::String::new(),
            command_options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RenameCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RenameCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RenameCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.ConnectPlayerCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectPlayerCommand {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.ConnectPlayerCommand.player_command_json)
    pub player_command_json: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.ConnectPlayerCommand.command_options)
    pub command_options: ::protobuf::MessageField<ConnectCommandOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.ConnectPlayerCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectPlayerCommand {
    fn default() -> &'a ConnectPlayerCommand {
        <ConnectPlayerCommand as ::protobuf::Message>::default_instance()
    }
}

impl ConnectPlayerCommand {
    pub fn new() -> ConnectPlayerCommand {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "player_command_json",
            |m: &ConnectPlayerCommand| { &m.player_command_json },
            |m: &mut ConnectPlayerCommand| { &mut m.player_command_json },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConnectCommandOptions>(
            "command_options",
            |m: &ConnectPlayerCommand| { &m.command_options },
            |m: &mut ConnectPlayerCommand| { &mut m.command_options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectPlayerCommand>(
            "ConnectPlayerCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectPlayerCommand {
    const NAME: &'static str = "ConnectPlayerCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_command_json = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.command_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.player_command_json.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.player_command_json);
        }
        if let Some(v) = self.command_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.player_command_json.is_empty() {
            os.write_string(1, &self.player_command_json)?;
        }
        if let Some(v) = self.command_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectPlayerCommand {
        ConnectPlayerCommand::new()
    }

    fn clear(&mut self) {
        self.player_command_json.clear();
        self.command_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectPlayerCommand {
        static instance: ConnectPlayerCommand = ConnectPlayerCommand {
            player_command_json: ::std::string::String::new(),
            command_options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectPlayerCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectPlayerCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectPlayerCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectPlayerCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.SetBackendMetadataCommand)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetBackendMetadataCommand {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.SetBackendMetadataCommand.metadata)
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.SetBackendMetadataCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetBackendMetadataCommand {
    fn default() -> &'a SetBackendMetadataCommand {
        <SetBackendMetadataCommand as ::protobuf::Message>::default_instance()
    }
}

impl SetBackendMetadataCommand {
    pub fn new() -> SetBackendMetadataCommand {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "metadata",
            |m: &SetBackendMetadataCommand| { &m.metadata },
            |m: &mut SetBackendMetadataCommand| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetBackendMetadataCommand>(
            "SetBackendMetadataCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetBackendMetadataCommand {
    const NAME: &'static str = "SetBackendMetadataCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.metadata.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetBackendMetadataCommand {
        SetBackendMetadataCommand::new()
    }

    fn clear(&mut self) {
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetBackendMetadataCommand {
        static instance: ::protobuf::rt::Lazy<SetBackendMetadataCommand> = ::protobuf::rt::Lazy::new();
        instance.get(SetBackendMetadataCommand::new)
    }
}

impl ::protobuf::MessageFull for SetBackendMetadataCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetBackendMetadataCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetBackendMetadataCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBackendMetadataCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.CommandAndSourceDevice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommandAndSourceDevice {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.CommandAndSourceDevice.command)
    pub command: ::std::string::String,
    // @@protoc_insertion_point(field:spotify.connectstate.CommandAndSourceDevice.source_device_info)
    pub source_device_info: ::protobuf::MessageField<DeviceInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.CommandAndSourceDevice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommandAndSourceDevice {
    fn default() -> &'a CommandAndSourceDevice {
        <CommandAndSourceDevice as ::protobuf::Message>::default_instance()
    }
}

impl CommandAndSourceDevice {
    pub fn new() -> CommandAndSourceDevice {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "command",
            |m: &CommandAndSourceDevice| { &m.command },
            |m: &mut CommandAndSourceDevice| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceInfo>(
            "source_device_info",
            |m: &CommandAndSourceDevice| { &m.source_device_info },
            |m: &mut CommandAndSourceDevice| { &mut m.source_device_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommandAndSourceDevice>(
            "CommandAndSourceDevice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommandAndSourceDevice {
    const NAME: &'static str = "CommandAndSourceDevice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.command = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source_device_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.command.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.command);
        }
        if let Some(v) = self.source_device_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.command.is_empty() {
            os.write_string(1, &self.command)?;
        }
        if let Some(v) = self.source_device_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommandAndSourceDevice {
        CommandAndSourceDevice::new()
    }

    fn clear(&mut self) {
        self.command.clear();
        self.source_device_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommandAndSourceDevice {
        static instance: CommandAndSourceDevice = CommandAndSourceDevice {
            command: ::std::string::String::new(),
            source_device_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CommandAndSourceDevice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommandAndSourceDevice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommandAndSourceDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommandAndSourceDevice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.ActiveDeviceUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActiveDeviceUpdate {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.ActiveDeviceUpdate.device_id)
    pub device_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.ActiveDeviceUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActiveDeviceUpdate {
    fn default() -> &'a ActiveDeviceUpdate {
        <ActiveDeviceUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ActiveDeviceUpdate {
    pub fn new() -> ActiveDeviceUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ActiveDeviceUpdate| { &m.device_id },
            |m: &mut ActiveDeviceUpdate| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActiveDeviceUpdate>(
            "ActiveDeviceUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActiveDeviceUpdate {
    const NAME: &'static str = "ActiveDeviceUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.device_id.is_empty() {
            os.write_string(1, &self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActiveDeviceUpdate {
        ActiveDeviceUpdate::new()
    }

    fn clear(&mut self) {
        self.device_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActiveDeviceUpdate {
        static instance: ActiveDeviceUpdate = ActiveDeviceUpdate {
            device_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActiveDeviceUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActiveDeviceUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActiveDeviceUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActiveDeviceUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:spotify.connectstate.StartedPlayingEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StartedPlayingEvent {
    // message fields
    // @@protoc_insertion_point(field:spotify.connectstate.StartedPlayingEvent.user_info_header)
    pub user_info_header: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:spotify.connectstate.StartedPlayingEvent.device_id)
    pub device_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:spotify.connectstate.StartedPlayingEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartedPlayingEvent {
    fn default() -> &'a StartedPlayingEvent {
        <StartedPlayingEvent as ::protobuf::Message>::default_instance()
    }
}

impl StartedPlayingEvent {
    pub fn new() -> StartedPlayingEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_info_header",
            |m: &StartedPlayingEvent| { &m.user_info_header },
            |m: &mut StartedPlayingEvent| { &mut m.user_info_header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &StartedPlayingEvent| { &m.device_id },
            |m: &mut StartedPlayingEvent| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StartedPlayingEvent>(
            "StartedPlayingEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StartedPlayingEvent {
    const NAME: &'static str = "StartedPlayingEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.user_info_header = is.read_bytes()?;
                },
                18 => {
                    self.device_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.user_info_header.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.user_info_header);
        }
        if !self.device_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.user_info_header.is_empty() {
            os.write_bytes(1, &self.user_info_header)?;
        }
        if !self.device_id.is_empty() {
            os.write_string(2, &self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartedPlayingEvent {
        StartedPlayingEvent::new()
    }

    fn clear(&mut self) {
        self.user_info_header.clear();
        self.device_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartedPlayingEvent {
        static instance: StartedPlayingEvent = StartedPlayingEvent {
            user_info_header: ::std::vec::Vec::new(),
            device_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StartedPlayingEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StartedPlayingEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StartedPlayingEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartedPlayingEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.connectstate.AudioOutputDeviceType)
pub enum AudioOutputDeviceType {
    // @@protoc_insertion_point(enum_value:spotify.connectstate.AudioOutputDeviceType.UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE)
    UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE = 0,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.AudioOutputDeviceType.BUILT_IN_SPEAKER)
    BUILT_IN_SPEAKER = 1,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.AudioOutputDeviceType.LINE_OUT)
    LINE_OUT = 2,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.AudioOutputDeviceType.BLUETOOTH)
    BLUETOOTH = 3,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.AudioOutputDeviceType.AIRPLAY)
    AIRPLAY = 4,
}

impl ::protobuf::Enum for AudioOutputDeviceType {
    const NAME: &'static str = "AudioOutputDeviceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AudioOutputDeviceType> {
        match value {
            0 => ::std::option::Option::Some(AudioOutputDeviceType::UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE),
            1 => ::std::option::Option::Some(AudioOutputDeviceType::BUILT_IN_SPEAKER),
            2 => ::std::option::Option::Some(AudioOutputDeviceType::LINE_OUT),
            3 => ::std::option::Option::Some(AudioOutputDeviceType::BLUETOOTH),
            4 => ::std::option::Option::Some(AudioOutputDeviceType::AIRPLAY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AudioOutputDeviceType> {
        match str {
            "UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE" => ::std::option::Option::Some(AudioOutputDeviceType::UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE),
            "BUILT_IN_SPEAKER" => ::std::option::Option::Some(AudioOutputDeviceType::BUILT_IN_SPEAKER),
            "LINE_OUT" => ::std::option::Option::Some(AudioOutputDeviceType::LINE_OUT),
            "BLUETOOTH" => ::std::option::Option::Some(AudioOutputDeviceType::BLUETOOTH),
            "AIRPLAY" => ::std::option::Option::Some(AudioOutputDeviceType::AIRPLAY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AudioOutputDeviceType] = &[
        AudioOutputDeviceType::UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE,
        AudioOutputDeviceType::BUILT_IN_SPEAKER,
        AudioOutputDeviceType::LINE_OUT,
        AudioOutputDeviceType::BLUETOOTH,
        AudioOutputDeviceType::AIRPLAY,
    ];
}

impl ::protobuf::EnumFull for AudioOutputDeviceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AudioOutputDeviceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AudioOutputDeviceType {
    fn default() -> Self {
        AudioOutputDeviceType::UNKNOWN_AUDIO_OUTPUT_DEVICE_TYPE
    }
}

impl AudioOutputDeviceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AudioOutputDeviceType>("AudioOutputDeviceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.connectstate.PutStateReason)
pub enum PutStateReason {
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.UNKNOWN_PUT_STATE_REASON)
    UNKNOWN_PUT_STATE_REASON = 0,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.SPIRC_HELLO)
    SPIRC_HELLO = 1,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.SPIRC_NOTIFY)
    SPIRC_NOTIFY = 2,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.NEW_DEVICE)
    NEW_DEVICE = 3,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.PLAYER_STATE_CHANGED)
    PLAYER_STATE_CHANGED = 4,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.VOLUME_CHANGED)
    VOLUME_CHANGED = 5,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.PICKER_OPENED)
    PICKER_OPENED = 6,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.BECAME_INACTIVE)
    BECAME_INACTIVE = 7,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.PutStateReason.ALIAS_CHANGED)
    ALIAS_CHANGED = 8,
}

impl ::protobuf::Enum for PutStateReason {
    const NAME: &'static str = "PutStateReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PutStateReason> {
        match value {
            0 => ::std::option::Option::Some(PutStateReason::UNKNOWN_PUT_STATE_REASON),
            1 => ::std::option::Option::Some(PutStateReason::SPIRC_HELLO),
            2 => ::std::option::Option::Some(PutStateReason::SPIRC_NOTIFY),
            3 => ::std::option::Option::Some(PutStateReason::NEW_DEVICE),
            4 => ::std::option::Option::Some(PutStateReason::PLAYER_STATE_CHANGED),
            5 => ::std::option::Option::Some(PutStateReason::VOLUME_CHANGED),
            6 => ::std::option::Option::Some(PutStateReason::PICKER_OPENED),
            7 => ::std::option::Option::Some(PutStateReason::BECAME_INACTIVE),
            8 => ::std::option::Option::Some(PutStateReason::ALIAS_CHANGED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PutStateReason> {
        match str {
            "UNKNOWN_PUT_STATE_REASON" => ::std::option::Option::Some(PutStateReason::UNKNOWN_PUT_STATE_REASON),
            "SPIRC_HELLO" => ::std::option::Option::Some(PutStateReason::SPIRC_HELLO),
            "SPIRC_NOTIFY" => ::std::option::Option::Some(PutStateReason::SPIRC_NOTIFY),
            "NEW_DEVICE" => ::std::option::Option::Some(PutStateReason::NEW_DEVICE),
            "PLAYER_STATE_CHANGED" => ::std::option::Option::Some(PutStateReason::PLAYER_STATE_CHANGED),
            "VOLUME_CHANGED" => ::std::option::Option::Some(PutStateReason::VOLUME_CHANGED),
            "PICKER_OPENED" => ::std::option::Option::Some(PutStateReason::PICKER_OPENED),
            "BECAME_INACTIVE" => ::std::option::Option::Some(PutStateReason::BECAME_INACTIVE),
            "ALIAS_CHANGED" => ::std::option::Option::Some(PutStateReason::ALIAS_CHANGED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PutStateReason] = &[
        PutStateReason::UNKNOWN_PUT_STATE_REASON,
        PutStateReason::SPIRC_HELLO,
        PutStateReason::SPIRC_NOTIFY,
        PutStateReason::NEW_DEVICE,
        PutStateReason::PLAYER_STATE_CHANGED,
        PutStateReason::VOLUME_CHANGED,
        PutStateReason::PICKER_OPENED,
        PutStateReason::BECAME_INACTIVE,
        PutStateReason::ALIAS_CHANGED,
    ];
}

impl ::protobuf::EnumFull for PutStateReason {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PutStateReason").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PutStateReason {
    fn default() -> Self {
        PutStateReason::UNKNOWN_PUT_STATE_REASON
    }
}

impl PutStateReason {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PutStateReason>("PutStateReason")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.connectstate.MemberType)
pub enum MemberType {
    // @@protoc_insertion_point(enum_value:spotify.connectstate.MemberType.SPIRC_V2)
    SPIRC_V2 = 0,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.MemberType.SPIRC_V3)
    SPIRC_V3 = 1,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.MemberType.CONNECT_STATE)
    CONNECT_STATE = 2,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.MemberType.CONNECT_STATE_EXTENDED)
    CONNECT_STATE_EXTENDED = 5,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.MemberType.ACTIVE_DEVICE_TRACKER)
    ACTIVE_DEVICE_TRACKER = 6,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.MemberType.PLAY_TOKEN)
    PLAY_TOKEN = 7,
}

impl ::protobuf::Enum for MemberType {
    const NAME: &'static str = "MemberType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MemberType> {
        match value {
            0 => ::std::option::Option::Some(MemberType::SPIRC_V2),
            1 => ::std::option::Option::Some(MemberType::SPIRC_V3),
            2 => ::std::option::Option::Some(MemberType::CONNECT_STATE),
            5 => ::std::option::Option::Some(MemberType::CONNECT_STATE_EXTENDED),
            6 => ::std::option::Option::Some(MemberType::ACTIVE_DEVICE_TRACKER),
            7 => ::std::option::Option::Some(MemberType::PLAY_TOKEN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MemberType> {
        match str {
            "SPIRC_V2" => ::std::option::Option::Some(MemberType::SPIRC_V2),
            "SPIRC_V3" => ::std::option::Option::Some(MemberType::SPIRC_V3),
            "CONNECT_STATE" => ::std::option::Option::Some(MemberType::CONNECT_STATE),
            "CONNECT_STATE_EXTENDED" => ::std::option::Option::Some(MemberType::CONNECT_STATE_EXTENDED),
            "ACTIVE_DEVICE_TRACKER" => ::std::option::Option::Some(MemberType::ACTIVE_DEVICE_TRACKER),
            "PLAY_TOKEN" => ::std::option::Option::Some(MemberType::PLAY_TOKEN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MemberType] = &[
        MemberType::SPIRC_V2,
        MemberType::SPIRC_V3,
        MemberType::CONNECT_STATE,
        MemberType::CONNECT_STATE_EXTENDED,
        MemberType::ACTIVE_DEVICE_TRACKER,
        MemberType::PLAY_TOKEN,
    ];
}

impl ::protobuf::EnumFull for MemberType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MemberType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MemberType::SPIRC_V2 => 0,
            MemberType::SPIRC_V3 => 1,
            MemberType::CONNECT_STATE => 2,
            MemberType::CONNECT_STATE_EXTENDED => 3,
            MemberType::ACTIVE_DEVICE_TRACKER => 4,
            MemberType::PLAY_TOKEN => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MemberType {
    fn default() -> Self {
        MemberType::SPIRC_V2
    }
}

impl MemberType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MemberType>("MemberType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.connectstate.ClusterUpdateReason)
pub enum ClusterUpdateReason {
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.UNKNOWN_CLUSTER_UPDATE_REASON)
    UNKNOWN_CLUSTER_UPDATE_REASON = 0,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.DEVICES_DISAPPEARED)
    DEVICES_DISAPPEARED = 1,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.DEVICE_STATE_CHANGED)
    DEVICE_STATE_CHANGED = 2,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.NEW_DEVICE_APPEARED)
    NEW_DEVICE_APPEARED = 3,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.DEVICE_VOLUME_CHANGED)
    DEVICE_VOLUME_CHANGED = 4,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.ClusterUpdateReason.DEVICE_ALIAS_CHANGED)
    DEVICE_ALIAS_CHANGED = 5,
}

impl ::protobuf::Enum for ClusterUpdateReason {
    const NAME: &'static str = "ClusterUpdateReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClusterUpdateReason> {
        match value {
            0 => ::std::option::Option::Some(ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON),
            1 => ::std::option::Option::Some(ClusterUpdateReason::DEVICES_DISAPPEARED),
            2 => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_STATE_CHANGED),
            3 => ::std::option::Option::Some(ClusterUpdateReason::NEW_DEVICE_APPEARED),
            4 => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_VOLUME_CHANGED),
            5 => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_ALIAS_CHANGED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ClusterUpdateReason> {
        match str {
            "UNKNOWN_CLUSTER_UPDATE_REASON" => ::std::option::Option::Some(ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON),
            "DEVICES_DISAPPEARED" => ::std::option::Option::Some(ClusterUpdateReason::DEVICES_DISAPPEARED),
            "DEVICE_STATE_CHANGED" => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_STATE_CHANGED),
            "NEW_DEVICE_APPEARED" => ::std::option::Option::Some(ClusterUpdateReason::NEW_DEVICE_APPEARED),
            "DEVICE_VOLUME_CHANGED" => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_VOLUME_CHANGED),
            "DEVICE_ALIAS_CHANGED" => ::std::option::Option::Some(ClusterUpdateReason::DEVICE_ALIAS_CHANGED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClusterUpdateReason] = &[
        ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON,
        ClusterUpdateReason::DEVICES_DISAPPEARED,
        ClusterUpdateReason::DEVICE_STATE_CHANGED,
        ClusterUpdateReason::NEW_DEVICE_APPEARED,
        ClusterUpdateReason::DEVICE_VOLUME_CHANGED,
        ClusterUpdateReason::DEVICE_ALIAS_CHANGED,
    ];
}

impl ::protobuf::EnumFull for ClusterUpdateReason {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClusterUpdateReason").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ClusterUpdateReason {
    fn default() -> Self {
        ClusterUpdateReason::UNKNOWN_CLUSTER_UPDATE_REASON
    }
}

impl ClusterUpdateReason {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClusterUpdateReason>("ClusterUpdateReason")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:spotify.connectstate.SendCommandResult)
pub enum SendCommandResult {
    // @@protoc_insertion_point(enum_value:spotify.connectstate.SendCommandResult.UNKNOWN_SEND_COMMAND_RESULT)
    UNKNOWN_SEND_COMMAND_RESULT = 0,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.SendCommandResult.SUCCESS)
    SUCCESS = 1,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.SendCommandResult.DEVICE_NOT_FOUND)
    DEVICE_NOT_FOUND = 2,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.SendCommandResult.CONTEXT_PLAYER_ERROR)
    CONTEXT_PLAYER_ERROR = 3,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.SendCommandResult.DEVICE_DISAPPEARED)
    DEVICE_DISAPPEARED = 4,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.SendCommandResult.UPSTREAM_ERROR)
    UPSTREAM_ERROR = 5,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.SendCommandResult.DEVICE_DOES_NOT_SUPPORT_COMMAND)
    DEVICE_DOES_NOT_SUPPORT_COMMAND = 6,
    // @@protoc_insertion_point(enum_value:spotify.connectstate.SendCommandResult.RATE_LIMITED)
    RATE_LIMITED = 7,
}

impl ::protobuf::Enum for SendCommandResult {
    const NAME: &'static str = "SendCommandResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SendCommandResult> {
        match value {
            0 => ::std::option::Option::Some(SendCommandResult::UNKNOWN_SEND_COMMAND_RESULT),
            1 => ::std::option::Option::Some(SendCommandResult::SUCCESS),
            2 => ::std::option::Option::Some(SendCommandResult::DEVICE_NOT_FOUND),
            3 => ::std::option::Option::Some(SendCommandResult::CONTEXT_PLAYER_ERROR),
            4 => ::std::option::Option::Some(SendCommandResult::DEVICE_DISAPPEARED),
            5 => ::std::option::Option::Some(SendCommandResult::UPSTREAM_ERROR),
            6 => ::std::option::Option::Some(SendCommandResult::DEVICE_DOES_NOT_SUPPORT_COMMAND),
            7 => ::std::option::Option::Some(SendCommandResult::RATE_LIMITED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SendCommandResult> {
        match str {
            "UNKNOWN_SEND_COMMAND_RESULT" => ::std::option::Option::Some(SendCommandResult::UNKNOWN_SEND_COMMAND_RESULT),
            "SUCCESS" => ::std::option::Option::Some(SendCommandResult::SUCCESS),
            "DEVICE_NOT_FOUND" => ::std::option::Option::Some(SendCommandResult::DEVICE_NOT_FOUND),
            "CONTEXT_PLAYER_ERROR" => ::std::option::Option::Some(SendCommandResult::CONTEXT_PLAYER_ERROR),
            "DEVICE_DISAPPEARED" => ::std::option::Option::Some(SendCommandResult::DEVICE_DISAPPEARED),
            "UPSTREAM_ERROR" => ::std::option::Option::Some(SendCommandResult::UPSTREAM_ERROR),
            "DEVICE_DOES_NOT_SUPPORT_COMMAND" => ::std::option::Option::Some(SendCommandResult::DEVICE_DOES_NOT_SUPPORT_COMMAND),
            "RATE_LIMITED" => ::std::option::Option::Some(SendCommandResult::RATE_LIMITED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SendCommandResult] = &[
        SendCommandResult::UNKNOWN_SEND_COMMAND_RESULT,
        SendCommandResult::SUCCESS,
        SendCommandResult::DEVICE_NOT_FOUND,
        SendCommandResult::CONTEXT_PLAYER_ERROR,
        SendCommandResult::DEVICE_DISAPPEARED,
        SendCommandResult::UPSTREAM_ERROR,
        SendCommandResult::DEVICE_DOES_NOT_SUPPORT_COMMAND,
        SendCommandResult::RATE_LIMITED,
    ];
}

impl ::protobuf::EnumFull for SendCommandResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SendCommandResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SendCommandResult {
    fn default() -> Self {
        SendCommandResult::UNKNOWN_SEND_COMMAND_RESULT
    }
}

impl SendCommandResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SendCommandResult>("SendCommandResult")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rconnect.proto\x12\x14spotify.connectstate\x1a\x0cplayer.proto\x1a\rd\
    evices.proto\"\xe1\x01\n\rClusterUpdate\x127\n\x07cluster\x18\x01\x20\
    \x01(\x0b2\x1d.spotify.connectstate.ClusterR\x07cluster\x12N\n\rupdate_r\
    eason\x18\x02\x20\x01(\x0e2).spotify.connectstate.ClusterUpdateReasonR\
    \x0cupdateReason\x12\x15\n\x06ack_id\x18\x03\x20\x01(\tR\x05ackId\x120\n\
    \x14devices_that_changed\x18\x04\x20\x03(\tR\x12devicesThatChanged\",\n\
    \x13PostCommandResponse\x12\x15\n\x06ack_id\x18\x01\x20\x01(\tR\x05ackId\
    \"\x8f\x02\n\x06Device\x12A\n\x0bdevice_info\x18\x01\x20\x01(\x0b2\x20.s\
    potify.connectstate.DeviceInfoR\ndeviceInfo\x12D\n\x0cplayer_state\x18\
    \x02\x20\x01(\x0b2!.spotify.connectstate.PlayerStateR\x0bplayerState\x12\
    W\n\x13private_device_info\x18\x03\x20\x01(\x0b2'.spotify.connectstate.P\
    rivateDeviceInfoR\x11privateDeviceInfo\x12#\n\rtransfer_data\x18\x04\x20\
    \x01(\x0cR\x0ctransferData\"\xcc\x04\n\x07Cluster\x120\n\x14changed_time\
    stamp_ms\x18\x01\x20\x01(\x03R\x12changedTimestampMs\x12(\n\x10active_de\
    vice_id\x18\x02\x20\x01(\tR\x0eactiveDeviceId\x12D\n\x0cplayer_state\x18\
    \x03\x20\x01(\x0b2!.spotify.connectstate.PlayerStateR\x0bplayerState\x12\
    A\n\x06device\x18\x04\x20\x03(\x0b2).spotify.connectstate.Cluster.Device\
    EntryR\x06device\x12#\n\rtransfer_data\x18\x05\x20\x01(\x0cR\x0ctransfer\
    Data\x126\n\x17transfer_data_timestamp\x18\x06\x20\x01(\x04R\x15transfer\
    DataTimestamp\x12=\n\x1bnot_playing_since_timestamp\x18\x07\x20\x01(\x03\
    R\x18notPlayingSinceTimestamp\x123\n\x16need_full_player_state\x18\x08\
    \x20\x01(\x08R\x13needFullPlayerState\x12.\n\x13server_timestamp_ms\x18\
    \t\x20\x01(\x03R\x11serverTimestampMs\x1a[\n\x0bDeviceEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x126\n\x05value\x18\x02\x20\x01(\x0b2\
    \x20.spotify.connectstate.DeviceInfoR\x05value:\x028\x01\"\x82\x05\n\x0f\
    PutStateRequest\x12!\n\x0ccallback_url\x18\x01\x20\x01(\tR\x0bcallbackUr\
    l\x124\n\x06device\x18\x02\x20\x01(\x0b2\x1c.spotify.connectstate.Device\
    R\x06device\x12A\n\x0bmember_type\x18\x03\x20\x01(\x0e2\x20.spotify.conn\
    ectstate.MemberTypeR\nmemberType\x12\x1b\n\tis_active\x18\x04\x20\x01(\
    \x08R\x08isActive\x12N\n\x10put_state_reason\x18\x05\x20\x01(\x0e2$.spot\
    ify.connectstate.PutStateReasonR\x0eputStateReason\x12\x1d\n\nmessage_id\
    \x18\x06\x20\x01(\rR\tmessageId\x12A\n\x1elast_command_sent_by_device_id\
    \x18\x07\x20\x01(\tR\x19lastCommandSentByDeviceId\x125\n\x17last_command\
    _message_id\x18\x08\x20\x01(\rR\x14lastCommandMessageId\x12,\n\x12starte\
    d_playing_at\x18\t\x20\x01(\x04R\x10startedPlayingAt\x124\n\x17has_been_\
    playing_for_ms\x18\x0b\x20\x01(\x04R\x13hasBeenPlayingForMs\x122\n\x15cl\
    ient_side_timestamp\x18\x0c\x20\x01(\x04R\x13clientSideTimestamp\x125\n\
    \x17only_write_player_state\x18\r\x20\x01(\x08R\x14onlyWritePlayerState\
    \"/\n\x11PrivateDeviceInfo\x12\x1a\n\x08platform\x18\x01\x20\x01(\tR\x08\
    platform\"5\n\x10SubscribeRequest\x12!\n\x0ccallback_url\x18\x01\x20\x01\
    (\tR\x0bcallbackUrl\"\xb4\x0b\n\nDeviceInfo\x12\x19\n\x08can_play\x18\
    \x01\x20\x01(\x08R\x07canPlay\x12\x16\n\x06volume\x18\x02\x20\x01(\rR\
    \x06volume\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12F\n\x0ccapab\
    ilities\x18\x04\x20\x01(\x0b2\".spotify.connectstate.CapabilitiesR\x0cca\
    pabilities\x12@\n\x08metadata\x18\x05\x20\x03(\x0b2$.spotify.connectstat\
    e.DeviceMetadataR\x08metadata\x126\n\x17device_software_version\x18\x06\
    \x20\x01(\tR\x15deviceSoftwareVersion\x12I\n\x0bdevice_type\x18\x07\x20\
    \x01(\x0e2(.spotify.connectstate.devices.DeviceTypeR\ndeviceType\x12#\n\
    \rspirc_version\x18\t\x20\x01(\tR\x0cspircVersion\x12\x1b\n\tdevice_id\
    \x18\n\x20\x01(\tR\x08deviceId\x12,\n\x12is_private_session\x18\x0b\x20\
    \x01(\x08R\x10isPrivateSession\x12*\n\x11is_social_connect\x18\x0c\x20\
    \x01(\x08R\x0fisSocialConnect\x12\x1b\n\tclient_id\x18\r\x20\x01(\tR\x08\
    clientId\x12\x14\n\x05brand\x18\x0e\x20\x01(\tR\x05brand\x12\x14\n\x05mo\
    del\x18\x0f\x20\x01(\tR\x05model\x12T\n\x0cmetadata_map\x18\x10\x20\x03(\
    \x0b21.spotify.connectstate.DeviceInfo.MetadataMapEntryR\x0bmetadataMap\
    \x12\x1d\n\nproduct_id\x18\x11\x20\x01(\tR\tproductId\x12)\n\x10deduplic\
    ation_id\x18\x12\x20\x01(\tR\x0fdeduplicationId\x12*\n\x11selected_alias\
    _id\x18\x13\x20\x01(\rR\x0fselectedAliasId\x12Z\n\x0edevice_aliases\x18\
    \x14\x20\x03(\x0b23.spotify.connectstate.DeviceInfo.DeviceAliasesEntryR\
    \rdeviceAliases\x12\x1d\n\nis_offline\x18\x15\x20\x01(\x08R\tisOffline\
    \x12\x1b\n\tpublic_ip\x18\x16\x20\x01(\tR\x08publicIp\x12\x18\n\x07licen\
    se\x18\x17\x20\x01(\tR\x07license\x12\x19\n\x08is_group\x18\x19\x20\x01(\
    \x08R\x07isGroup\x12*\n\x11is_dynamic_device\x18\x1a\x20\x01(\x08R\x0fis\
    DynamicDevice\x12:\n\x19disallow_playback_reasons\x18\x1b\x20\x03(\tR\
    \x17disallowPlaybackReasons\x12:\n\x19disallow_transfer_reasons\x18\x1c\
    \x20\x03(\tR\x17disallowTransferReasons\x12f\n\x18audio_output_device_in\
    fo\x18\x18\x20\x01(\x0b2+.spotify.connectstate.AudioOutputDeviceInfoH\0R\
    \x15audioOutputDeviceInfo\x1a>\n\x10MetadataMapEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\x1ak\n\x12DeviceAliasesEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\rR\x03key\x12?\n\x05value\x18\x02\x20\x01(\x0b2).spotify.connectst\
    ate.devices.DeviceAliasR\x05value:\x028\x01B\x1b\n\x19_audio_output_devi\
    ce_info\"\xcf\x01\n\x15AudioOutputDeviceInfo\x12f\n\x18audio_output_devi\
    ce_type\x18\x01\x20\x01(\x0e2+.spotify.connectstate.AudioOutputDeviceTyp\
    eH\0R\x15audioOutputDeviceType\x12!\n\x0bdevice_name\x18\x02\x20\x01(\tH\
    \x01R\ndeviceNameB\x1b\n\x19_audio_output_device_typeB\x0e\n\x0c_device_\
    name\"D\n\x0eDeviceMetadata\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04typ\
    e\x12\x1a\n\x08metadata\x18\x02\x20\x01(\tR\x08metadata:\x02\x18\x01\"\
    \x89\t\n\x0cCapabilities\x12\"\n\rcan_be_player\x18\x02\x20\x01(\x08R\
    \x0bcanBePlayer\x12*\n\x11restrict_to_local\x18\x03\x20\x01(\x08R\x0fres\
    trictToLocal\x12+\n\x12gaia_eq_connect_id\x18\x05\x20\x01(\x08R\x0fgaiaE\
    qConnectId\x12'\n\x0fsupports_logout\x18\x06\x20\x01(\x08R\x0esupportsLo\
    gout\x12#\n\ris_observable\x18\x07\x20\x01(\x08R\x0cisObservable\x12!\n\
    \x0cvolume_steps\x18\x08\x20\x01(\x05R\x0bvolumeSteps\x12'\n\x0fsupporte\
    d_types\x18\t\x20\x03(\tR\x0esupportedTypes\x12!\n\x0ccommand_acks\x18\n\
    \x20\x01(\x08R\x0bcommandAcks\x12'\n\x0fsupports_rename\x18\x0b\x20\x01(\
    \x08R\x0esupportsRename\x12\x16\n\x06hidden\x18\x0c\x20\x01(\x08R\x06hid\
    den\x12%\n\x0edisable_volume\x18\r\x20\x01(\x08R\rdisableVolume\x12)\n\
    \x10connect_disabled\x18\x0e\x20\x01(\x08R\x0fconnectDisabled\x120\n\x14\
    supports_playlist_v2\x18\x0f\x20\x01(\x08R\x12supportsPlaylistV2\x12'\n\
    \x0fis_controllable\x18\x10\x20\x01(\x08R\x0eisControllable\x12<\n\x1asu\
    pports_external_episodes\x18\x11\x20\x01(\x08R\x18supportsExternalEpisod\
    es\x12A\n\x1dsupports_set_backend_metadata\x18\x12\x20\x01(\x08R\x1asupp\
    ortsSetBackendMetadata\x12:\n\x19supports_transfer_command\x18\x13\x20\
    \x01(\x08R\x17supportsTransferCommand\x128\n\x18supports_command_request\
    \x18\x14\x20\x01(\x08R\x16supportsCommandRequest\x12(\n\x10is_voice_enab\
    led\x18\x15\x20\x01(\x08R\x0eisVoiceEnabled\x125\n\x17needs_full_player_\
    state\x18\x16\x20\x01(\x08R\x14needsFullPlayerState\x120\n\x14supports_g\
    zip_pushes\x18\x17\x20\x01(\x08R\x12supportsGzipPushes\x12?\n\x1csupport\
    s_set_options_command\x18\x19\x20\x01(\x08R\x19supportsSetOptionsCommand\
    \x12S\n\rsupports_hifi\x18\x1a\x20\x01(\x0b2..spotify.connectstate.Capab\
    ilitySupportDetailsR\x0csupportsHifi\x121\n\x14connect_capabilities\x18\
    \x1b\x20\x01(\tR\x13connectCapabilities\"\x93\x01\n\x18CapabilitySupport\
    Details\x12'\n\x0ffully_supported\x18\x01\x20\x01(\x08R\x0efullySupporte\
    d\x12#\n\ruser_eligible\x18\x02\x20\x01(\x08R\x0cuserEligible\x12)\n\x10\
    device_supported\x18\x03\x20\x01(\x08R\x0fdeviceSupported\"^\n\x15Connec\
    tCommandOptions\x12\x1d\n\nmessage_id\x18\x01\x20\x01(\x05R\tmessageId\
    \x12&\n\x0ftarget_alias_id\x18\x03\x20\x01(\rR\rtargetAliasId\"e\n\rLogo\
    utCommand\x12T\n\x0fcommand_options\x18\x01\x20\x01(\x0b2+.spotify.conne\
    ctstate.ConnectCommandOptionsR\x0ecommandOptions\"\x80\x01\n\x10SetVolum\
    eCommand\x12\x16\n\x06volume\x18\x01\x20\x01(\x05R\x06volume\x12T\n\x0fc\
    ommand_options\x18\x02\x20\x01(\x0b2+.spotify.connectstate.ConnectComman\
    dOptionsR\x0ecommandOptions\"\x82\x01\n\rRenameCommand\x12\x1b\n\trename\
    _to\x18\x01\x20\x01(\tR\x08renameTo\x12T\n\x0fcommand_options\x18\x02\
    \x20\x01(\x0b2+.spotify.connectstate.ConnectCommandOptionsR\x0ecommandOp\
    tions\"\x9c\x01\n\x14ConnectPlayerCommand\x12.\n\x13player_command_json\
    \x18\x01\x20\x01(\tR\x11playerCommandJson\x12T\n\x0fcommand_options\x18\
    \x02\x20\x01(\x0b2+.spotify.connectstate.ConnectCommandOptionsR\x0ecomma\
    ndOptions\"\xb3\x01\n\x19SetBackendMetadataCommand\x12Y\n\x08metadata\
    \x18\x01\x20\x03(\x0b2=.spotify.connectstate.SetBackendMetadataCommand.M\
    etadataEntryR\x08metadata\x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"\x82\x01\n\x16CommandAndSourceDevice\x12\x18\n\x07command\x18\x01\
    \x20\x01(\tR\x07command\x12N\n\x12source_device_info\x18\x02\x20\x01(\
    \x0b2\x20.spotify.connectstate.DeviceInfoR\x10sourceDeviceInfo\"1\n\x12A\
    ctiveDeviceUpdate\x12\x1b\n\tdevice_id\x18\x01\x20\x01(\tR\x08deviceId\"\
    \\\n\x13StartedPlayingEvent\x12(\n\x10user_info_header\x18\x01\x20\x01(\
    \x0cR\x0euserInfoHeader\x12\x1b\n\tdevice_id\x18\x02\x20\x01(\tR\x08devi\
    ceId*}\n\x15AudioOutputDeviceType\x12$\n\x20UNKNOWN_AUDIO_OUTPUT_DEVICE_\
    TYPE\x10\0\x12\x14\n\x10BUILT_IN_SPEAKER\x10\x01\x12\x0c\n\x08LINE_OUT\
    \x10\x02\x12\r\n\tBLUETOOTH\x10\x03\x12\x0b\n\x07AIRPLAY\x10\x04*\xca\
    \x01\n\x0ePutStateReason\x12\x1c\n\x18UNKNOWN_PUT_STATE_REASON\x10\0\x12\
    \x0f\n\x0bSPIRC_HELLO\x10\x01\x12\x10\n\x0cSPIRC_NOTIFY\x10\x02\x12\x0e\
    \n\nNEW_DEVICE\x10\x03\x12\x18\n\x14PLAYER_STATE_CHANGED\x10\x04\x12\x12\
    \n\x0eVOLUME_CHANGED\x10\x05\x12\x11\n\rPICKER_OPENED\x10\x06\x12\x13\n\
    \x0fBECAME_INACTIVE\x10\x07\x12\x11\n\rALIAS_CHANGED\x10\x08*\x82\x01\n\
    \nMemberType\x12\x0c\n\x08SPIRC_V2\x10\0\x12\x0c\n\x08SPIRC_V3\x10\x01\
    \x12\x11\n\rCONNECT_STATE\x10\x02\x12\x1a\n\x16CONNECT_STATE_EXTENDED\
    \x10\x05\x12\x19\n\x15ACTIVE_DEVICE_TRACKER\x10\x06\x12\x0e\n\nPLAY_TOKE\
    N\x10\x07*\xb9\x01\n\x13ClusterUpdateReason\x12!\n\x1dUNKNOWN_CLUSTER_UP\
    DATE_REASON\x10\0\x12\x17\n\x13DEVICES_DISAPPEARED\x10\x01\x12\x18\n\x14\
    DEVICE_STATE_CHANGED\x10\x02\x12\x17\n\x13NEW_DEVICE_APPEARED\x10\x03\
    \x12\x19\n\x15DEVICE_VOLUME_CHANGED\x10\x04\x12\x18\n\x14DEVICE_ALIAS_CH\
    ANGED\x10\x05*\xd4\x01\n\x11SendCommandResult\x12\x1f\n\x1bUNKNOWN_SEND_\
    COMMAND_RESULT\x10\0\x12\x0b\n\x07SUCCESS\x10\x01\x12\x14\n\x10DEVICE_NO\
    T_FOUND\x10\x02\x12\x18\n\x14CONTEXT_PLAYER_ERROR\x10\x03\x12\x16\n\x12D\
    EVICE_DISAPPEARED\x10\x04\x12\x12\n\x0eUPSTREAM_ERROR\x10\x05\x12#\n\x1f\
    DEVICE_DOES_NOT_SUPPORT_COMMAND\x10\x06\x12\x10\n\x0cRATE_LIMITED\x10\
    \x07B\"\n\x1ecom.spotify.connectstate.modelH\x02b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::player::file_descriptor().clone());
            deps.push(super::devices::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(21);
            messages.push(ClusterUpdate::generated_message_descriptor_data());
            messages.push(PostCommandResponse::generated_message_descriptor_data());
            messages.push(Device::generated_message_descriptor_data());
            messages.push(Cluster::generated_message_descriptor_data());
            messages.push(PutStateRequest::generated_message_descriptor_data());
            messages.push(PrivateDeviceInfo::generated_message_descriptor_data());
            messages.push(SubscribeRequest::generated_message_descriptor_data());
            messages.push(DeviceInfo::generated_message_descriptor_data());
            messages.push(AudioOutputDeviceInfo::generated_message_descriptor_data());
            messages.push(DeviceMetadata::generated_message_descriptor_data());
            messages.push(Capabilities::generated_message_descriptor_data());
            messages.push(CapabilitySupportDetails::generated_message_descriptor_data());
            messages.push(ConnectCommandOptions::generated_message_descriptor_data());
            messages.push(LogoutCommand::generated_message_descriptor_data());
            messages.push(SetVolumeCommand::generated_message_descriptor_data());
            messages.push(RenameCommand::generated_message_descriptor_data());
            messages.push(ConnectPlayerCommand::generated_message_descriptor_data());
            messages.push(SetBackendMetadataCommand::generated_message_descriptor_data());
            messages.push(CommandAndSourceDevice::generated_message_descriptor_data());
            messages.push(ActiveDeviceUpdate::generated_message_descriptor_data());
            messages.push(StartedPlayingEvent::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(AudioOutputDeviceType::generated_enum_descriptor_data());
            enums.push(PutStateReason::generated_enum_descriptor_data());
            enums.push(MemberType::generated_enum_descriptor_data());
            enums.push(ClusterUpdateReason::generated_enum_descriptor_data());
            enums.push(SendCommandResult::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
