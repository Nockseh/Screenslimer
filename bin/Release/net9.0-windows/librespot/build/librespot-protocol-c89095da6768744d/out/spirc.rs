// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `spirc.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:Frame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Frame {
    // message fields
    // @@protoc_insertion_point(field:Frame.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Frame.ident)
    pub ident: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Frame.protocol_version)
    pub protocol_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Frame.seq_nr)
    pub seq_nr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Frame.typ)
    pub typ: ::std::option::Option<::protobuf::EnumOrUnknown<MessageType>>,
    // @@protoc_insertion_point(field:Frame.device_state)
    pub device_state: ::protobuf::MessageField<DeviceState>,
    // @@protoc_insertion_point(field:Frame.goodbye)
    pub goodbye: ::protobuf::MessageField<Goodbye>,
    // @@protoc_insertion_point(field:Frame.state)
    pub state: ::protobuf::MessageField<State>,
    // @@protoc_insertion_point(field:Frame.position)
    pub position: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Frame.volume)
    pub volume: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:Frame.state_update_id)
    pub state_update_id: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:Frame.recipient)
    pub recipient: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:Frame.context_player_state)
    pub context_player_state: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:Frame.new_name)
    pub new_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Frame.metadata)
    pub metadata: ::protobuf::MessageField<Metadata>,
    // special fields
    // @@protoc_insertion_point(special_field:Frame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Frame {
    fn default() -> &'a Frame {
        <Frame as ::protobuf::Message>::default_instance()
    }
}

impl Frame {
    pub fn new() -> Frame {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional string ident = 2;

    pub fn ident(&self) -> &str {
        match self.ident.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ident(&mut self) {
        self.ident = ::std::option::Option::None;
    }

    pub fn has_ident(&self) -> bool {
        self.ident.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ident(&mut self, v: ::std::string::String) {
        self.ident = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ident(&mut self) -> &mut ::std::string::String {
        if self.ident.is_none() {
            self.ident = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ident.as_mut().unwrap()
    }

    // Take field
    pub fn take_ident(&mut self) -> ::std::string::String {
        self.ident.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string protocol_version = 3;

    pub fn protocol_version(&self) -> &str {
        match self.protocol_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: ::std::string::String) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol_version(&mut self) -> &mut ::std::string::String {
        if self.protocol_version.is_none() {
            self.protocol_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.protocol_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol_version(&mut self) -> ::std::string::String {
        self.protocol_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 seq_nr = 4;

    pub fn seq_nr(&self) -> u32 {
        self.seq_nr.unwrap_or(0)
    }

    pub fn clear_seq_nr(&mut self) {
        self.seq_nr = ::std::option::Option::None;
    }

    pub fn has_seq_nr(&self) -> bool {
        self.seq_nr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_nr(&mut self, v: u32) {
        self.seq_nr = ::std::option::Option::Some(v);
    }

    // optional .MessageType typ = 5;

    pub fn typ(&self) -> MessageType {
        match self.typ {
            Some(e) => e.enum_value_or(MessageType::kMessageTypeHello),
            None => MessageType::kMessageTypeHello,
        }
    }

    pub fn clear_typ(&mut self) {
        self.typ = ::std::option::Option::None;
    }

    pub fn has_typ(&self) -> bool {
        self.typ.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typ(&mut self, v: MessageType) {
        self.typ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 position = 13;

    pub fn position(&self) -> u32 {
        self.position.unwrap_or(0)
    }

    pub fn clear_position(&mut self) {
        self.position = ::std::option::Option::None;
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: u32) {
        self.position = ::std::option::Option::Some(v);
    }

    // optional uint32 volume = 14;

    pub fn volume(&self) -> u32 {
        self.volume.unwrap_or(0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: u32) {
        self.volume = ::std::option::Option::Some(v);
    }

    // optional int64 state_update_id = 17;

    pub fn state_update_id(&self) -> i64 {
        self.state_update_id.unwrap_or(0)
    }

    pub fn clear_state_update_id(&mut self) {
        self.state_update_id = ::std::option::Option::None;
    }

    pub fn has_state_update_id(&self) -> bool {
        self.state_update_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_update_id(&mut self, v: i64) {
        self.state_update_id = ::std::option::Option::Some(v);
    }

    // optional bytes context_player_state = 19;

    pub fn context_player_state(&self) -> &[u8] {
        match self.context_player_state.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_context_player_state(&mut self) {
        self.context_player_state = ::std::option::Option::None;
    }

    pub fn has_context_player_state(&self) -> bool {
        self.context_player_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_player_state(&mut self, v: ::std::vec::Vec<u8>) {
        self.context_player_state = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context_player_state(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.context_player_state.is_none() {
            self.context_player_state = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.context_player_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_context_player_state(&mut self) -> ::std::vec::Vec<u8> {
        self.context_player_state.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string new_name = 20;

    pub fn new_name(&self) -> &str {
        match self.new_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_new_name(&mut self) {
        self.new_name = ::std::option::Option::None;
    }

    pub fn has_new_name(&self) -> bool {
        self.new_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_name(&mut self, v: ::std::string::String) {
        self.new_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_name(&mut self) -> &mut ::std::string::String {
        if self.new_name.is_none() {
            self.new_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.new_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_name(&mut self) -> ::std::string::String {
        self.new_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &Frame| { &m.version },
            |m: &mut Frame| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ident",
            |m: &Frame| { &m.ident },
            |m: &mut Frame| { &mut m.ident },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &Frame| { &m.protocol_version },
            |m: &mut Frame| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_nr",
            |m: &Frame| { &m.seq_nr },
            |m: &mut Frame| { &mut m.seq_nr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "typ",
            |m: &Frame| { &m.typ },
            |m: &mut Frame| { &mut m.typ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeviceState>(
            "device_state",
            |m: &Frame| { &m.device_state },
            |m: &mut Frame| { &mut m.device_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Goodbye>(
            "goodbye",
            |m: &Frame| { &m.goodbye },
            |m: &mut Frame| { &mut m.goodbye },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, State>(
            "state",
            |m: &Frame| { &m.state },
            |m: &mut Frame| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "position",
            |m: &Frame| { &m.position },
            |m: &mut Frame| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &Frame| { &m.volume },
            |m: &mut Frame| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state_update_id",
            |m: &Frame| { &m.state_update_id },
            |m: &mut Frame| { &mut m.state_update_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "recipient",
            |m: &Frame| { &m.recipient },
            |m: &mut Frame| { &mut m.recipient },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context_player_state",
            |m: &Frame| { &m.context_player_state },
            |m: &mut Frame| { &mut m.context_player_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_name",
            |m: &Frame| { &m.new_name },
            |m: &mut Frame| { &mut m.new_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Metadata>(
            "metadata",
            |m: &Frame| { &m.metadata },
            |m: &mut Frame| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Frame>(
            "Frame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Frame {
    const NAME: &'static str = "Frame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.ident = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.seq_nr = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.typ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.device_state)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.goodbye)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                104 => {
                    self.position = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.volume = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.state_update_id = ::std::option::Option::Some(is.read_int64()?);
                },
                146 => {
                    self.recipient.push(is.read_string()?);
                },
                154 => {
                    self.context_player_state = ::std::option::Option::Some(is.read_bytes()?);
                },
                162 => {
                    self.new_name = ::std::option::Option::Some(is.read_string()?);
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ident.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.protocol_version.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.seq_nr {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.typ {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.device_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.goodbye.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.position {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.state_update_id {
            my_size += ::protobuf::rt::int64_size(17, v);
        }
        for value in &self.recipient {
            my_size += ::protobuf::rt::string_size(18, &value);
        };
        if let Some(v) = self.context_player_state.as_ref() {
            my_size += ::protobuf::rt::bytes_size(19, &v);
        }
        if let Some(v) = self.new_name.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ident.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.protocol_version.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.seq_nr {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.typ {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.device_state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.goodbye.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.position {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.volume {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.state_update_id {
            os.write_int64(17, v)?;
        }
        for v in &self.recipient {
            os.write_string(18, &v)?;
        };
        if let Some(v) = self.context_player_state.as_ref() {
            os.write_bytes(19, v)?;
        }
        if let Some(v) = self.new_name.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Frame {
        Frame::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.ident = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.seq_nr = ::std::option::Option::None;
        self.typ = ::std::option::Option::None;
        self.device_state.clear();
        self.goodbye.clear();
        self.state.clear();
        self.position = ::std::option::Option::None;
        self.volume = ::std::option::Option::None;
        self.state_update_id = ::std::option::Option::None;
        self.recipient.clear();
        self.context_player_state = ::std::option::Option::None;
        self.new_name = ::std::option::Option::None;
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Frame {
        static instance: Frame = Frame {
            version: ::std::option::Option::None,
            ident: ::std::option::Option::None,
            protocol_version: ::std::option::Option::None,
            seq_nr: ::std::option::Option::None,
            typ: ::std::option::Option::None,
            device_state: ::protobuf::MessageField::none(),
            goodbye: ::protobuf::MessageField::none(),
            state: ::protobuf::MessageField::none(),
            position: ::std::option::Option::None,
            volume: ::std::option::Option::None,
            state_update_id: ::std::option::Option::None,
            recipient: ::std::vec::Vec::new(),
            context_player_state: ::std::option::Option::None,
            new_name: ::std::option::Option::None,
            metadata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Frame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Frame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Frame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Frame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DeviceState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceState {
    // message fields
    // @@protoc_insertion_point(field:DeviceState.sw_version)
    pub sw_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:DeviceState.is_active)
    pub is_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:DeviceState.can_play)
    pub can_play: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:DeviceState.volume)
    pub volume: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeviceState.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:DeviceState.error_code)
    pub error_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeviceState.became_active_at)
    pub became_active_at: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:DeviceState.error_message)
    pub error_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:DeviceState.capabilities)
    pub capabilities: ::std::vec::Vec<Capability>,
    // @@protoc_insertion_point(field:DeviceState.context_player_error)
    pub context_player_error: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:DeviceState.metadata)
    pub metadata: ::std::vec::Vec<Metadata>,
    // special fields
    // @@protoc_insertion_point(special_field:DeviceState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceState {
    fn default() -> &'a DeviceState {
        <DeviceState as ::protobuf::Message>::default_instance()
    }
}

impl DeviceState {
    pub fn new() -> DeviceState {
        ::std::default::Default::default()
    }

    // optional string sw_version = 1;

    pub fn sw_version(&self) -> &str {
        match self.sw_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sw_version(&mut self) {
        self.sw_version = ::std::option::Option::None;
    }

    pub fn has_sw_version(&self) -> bool {
        self.sw_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sw_version(&mut self, v: ::std::string::String) {
        self.sw_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sw_version(&mut self) -> &mut ::std::string::String {
        if self.sw_version.is_none() {
            self.sw_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sw_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_sw_version(&mut self) -> ::std::string::String {
        self.sw_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_active = 10;

    pub fn is_active(&self) -> bool {
        self.is_active.unwrap_or(false)
    }

    pub fn clear_is_active(&mut self) {
        self.is_active = ::std::option::Option::None;
    }

    pub fn has_is_active(&self) -> bool {
        self.is_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_active(&mut self, v: bool) {
        self.is_active = ::std::option::Option::Some(v);
    }

    // optional bool can_play = 11;

    pub fn can_play(&self) -> bool {
        self.can_play.unwrap_or(false)
    }

    pub fn clear_can_play(&mut self) {
        self.can_play = ::std::option::Option::None;
    }

    pub fn has_can_play(&self) -> bool {
        self.can_play.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_play(&mut self, v: bool) {
        self.can_play = ::std::option::Option::Some(v);
    }

    // optional uint32 volume = 12;

    pub fn volume(&self) -> u32 {
        self.volume.unwrap_or(0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: u32) {
        self.volume = ::std::option::Option::Some(v);
    }

    // optional string name = 13;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 error_code = 14;

    pub fn error_code(&self) -> u32 {
        self.error_code.unwrap_or(0)
    }

    pub fn clear_error_code(&mut self) {
        self.error_code = ::std::option::Option::None;
    }

    pub fn has_error_code(&self) -> bool {
        self.error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: u32) {
        self.error_code = ::std::option::Option::Some(v);
    }

    // optional int64 became_active_at = 15;

    pub fn became_active_at(&self) -> i64 {
        self.became_active_at.unwrap_or(0)
    }

    pub fn clear_became_active_at(&mut self) {
        self.became_active_at = ::std::option::Option::None;
    }

    pub fn has_became_active_at(&self) -> bool {
        self.became_active_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_became_active_at(&mut self, v: i64) {
        self.became_active_at = ::std::option::Option::Some(v);
    }

    // optional string error_message = 16;

    pub fn error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_message(&mut self) {
        self.error_message = ::std::option::Option::None;
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string context_player_error = 20;

    pub fn context_player_error(&self) -> &str {
        match self.context_player_error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_context_player_error(&mut self) {
        self.context_player_error = ::std::option::Option::None;
    }

    pub fn has_context_player_error(&self) -> bool {
        self.context_player_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_player_error(&mut self, v: ::std::string::String) {
        self.context_player_error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context_player_error(&mut self) -> &mut ::std::string::String {
        if self.context_player_error.is_none() {
            self.context_player_error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.context_player_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_context_player_error(&mut self) -> ::std::string::String {
        self.context_player_error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sw_version",
            |m: &DeviceState| { &m.sw_version },
            |m: &mut DeviceState| { &mut m.sw_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_active",
            |m: &DeviceState| { &m.is_active },
            |m: &mut DeviceState| { &mut m.is_active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_play",
            |m: &DeviceState| { &m.can_play },
            |m: &mut DeviceState| { &mut m.can_play },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &DeviceState| { &m.volume },
            |m: &mut DeviceState| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &DeviceState| { &m.name },
            |m: &mut DeviceState| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_code",
            |m: &DeviceState| { &m.error_code },
            |m: &mut DeviceState| { &mut m.error_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "became_active_at",
            |m: &DeviceState| { &m.became_active_at },
            |m: &mut DeviceState| { &mut m.became_active_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_message",
            |m: &DeviceState| { &m.error_message },
            |m: &mut DeviceState| { &mut m.error_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "capabilities",
            |m: &DeviceState| { &m.capabilities },
            |m: &mut DeviceState| { &mut m.capabilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context_player_error",
            |m: &DeviceState| { &m.context_player_error },
            |m: &mut DeviceState| { &mut m.context_player_error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metadata",
            |m: &DeviceState| { &m.metadata },
            |m: &mut DeviceState| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceState>(
            "DeviceState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceState {
    const NAME: &'static str = "DeviceState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sw_version = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.is_active = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.can_play = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.volume = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.error_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.became_active_at = ::std::option::Option::Some(is.read_int64()?);
                },
                130 => {
                    self.error_message = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.capabilities.push(is.read_message()?);
                },
                162 => {
                    self.context_player_error = ::std::option::Option::Some(is.read_string()?);
                },
                202 => {
                    self.metadata.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sw_version.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.is_active {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_play {
            my_size += 1 + 1;
        }
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.error_code {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.became_active_at {
            my_size += ::protobuf::rt::int64_size(15, v);
        }
        if let Some(v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        for value in &self.capabilities {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.context_player_error.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        for value in &self.metadata {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sw_version.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.is_active {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.can_play {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.volume {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.error_code {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.became_active_at {
            os.write_int64(15, v)?;
        }
        if let Some(v) = self.error_message.as_ref() {
            os.write_string(16, v)?;
        }
        for v in &self.capabilities {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.context_player_error.as_ref() {
            os.write_string(20, v)?;
        }
        for v in &self.metadata {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceState {
        DeviceState::new()
    }

    fn clear(&mut self) {
        self.sw_version = ::std::option::Option::None;
        self.is_active = ::std::option::Option::None;
        self.can_play = ::std::option::Option::None;
        self.volume = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.error_code = ::std::option::Option::None;
        self.became_active_at = ::std::option::Option::None;
        self.error_message = ::std::option::Option::None;
        self.capabilities.clear();
        self.context_player_error = ::std::option::Option::None;
        self.metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceState {
        static instance: DeviceState = DeviceState {
            sw_version: ::std::option::Option::None,
            is_active: ::std::option::Option::None,
            can_play: ::std::option::Option::None,
            volume: ::std::option::Option::None,
            name: ::std::option::Option::None,
            error_code: ::std::option::Option::None,
            became_active_at: ::std::option::Option::None,
            error_message: ::std::option::Option::None,
            capabilities: ::std::vec::Vec::new(),
            context_player_error: ::std::option::Option::None,
            metadata: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Capability)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Capability {
    // message fields
    // @@protoc_insertion_point(field:Capability.typ)
    pub typ: ::std::option::Option<::protobuf::EnumOrUnknown<CapabilityType>>,
    // @@protoc_insertion_point(field:Capability.intValue)
    pub intValue: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:Capability.stringValue)
    pub stringValue: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Capability.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Capability {
    fn default() -> &'a Capability {
        <Capability as ::protobuf::Message>::default_instance()
    }
}

impl Capability {
    pub fn new() -> Capability {
        ::std::default::Default::default()
    }

    // optional .CapabilityType typ = 1;

    pub fn typ(&self) -> CapabilityType {
        match self.typ {
            Some(e) => e.enum_value_or(CapabilityType::kSupportedContexts),
            None => CapabilityType::kSupportedContexts,
        }
    }

    pub fn clear_typ(&mut self) {
        self.typ = ::std::option::Option::None;
    }

    pub fn has_typ(&self) -> bool {
        self.typ.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typ(&mut self, v: CapabilityType) {
        self.typ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "typ",
            |m: &Capability| { &m.typ },
            |m: &mut Capability| { &mut m.typ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "intValue",
            |m: &Capability| { &m.intValue },
            |m: &mut Capability| { &mut m.intValue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stringValue",
            |m: &Capability| { &m.stringValue },
            |m: &mut Capability| { &mut m.stringValue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Capability>(
            "Capability",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Capability {
    const NAME: &'static str = "Capability";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.typ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    is.read_repeated_packed_int64_into(&mut self.intValue)?;
                },
                16 => {
                    self.intValue.push(is.read_int64()?);
                },
                26 => {
                    self.stringValue.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.typ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.intValue {
            my_size += ::protobuf::rt::int64_size(2, *value);
        };
        for value in &self.stringValue {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.typ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.intValue {
            os.write_int64(2, *v)?;
        };
        for v in &self.stringValue {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Capability {
        Capability::new()
    }

    fn clear(&mut self) {
        self.typ = ::std::option::Option::None;
        self.intValue.clear();
        self.stringValue.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Capability {
        static instance: Capability = Capability {
            typ: ::std::option::Option::None,
            intValue: ::std::vec::Vec::new(),
            stringValue: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Capability {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Capability").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Capability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Capability {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Goodbye)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Goodbye {
    // message fields
    // @@protoc_insertion_point(field:Goodbye.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Goodbye.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Goodbye {
    fn default() -> &'a Goodbye {
        <Goodbye as ::protobuf::Message>::default_instance()
    }
}

impl Goodbye {
    pub fn new() -> Goodbye {
        ::std::default::Default::default()
    }

    // optional string reason = 1;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &Goodbye| { &m.reason },
            |m: &mut Goodbye| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Goodbye>(
            "Goodbye",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Goodbye {
    const NAME: &'static str = "Goodbye";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reason.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Goodbye {
        Goodbye::new()
    }

    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Goodbye {
        static instance: Goodbye = Goodbye {
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Goodbye {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Goodbye").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Goodbye {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Goodbye {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:State)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct State {
    // message fields
    // @@protoc_insertion_point(field:State.context_uri)
    pub context_uri: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:State.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:State.position_ms)
    pub position_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:State.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<PlayStatus>>,
    // @@protoc_insertion_point(field:State.position_measured_at)
    pub position_measured_at: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:State.context_description)
    pub context_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:State.shuffle)
    pub shuffle: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:State.repeat)
    pub repeat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:State.last_command_ident)
    pub last_command_ident: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:State.last_command_msgid)
    pub last_command_msgid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:State.playing_from_fallback)
    pub playing_from_fallback: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:State.row)
    pub row: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:State.playing_track_index)
    pub playing_track_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:State.track)
    pub track: ::std::vec::Vec<TrackRef>,
    // @@protoc_insertion_point(field:State.ad)
    pub ad: ::protobuf::MessageField<Ad>,
    // special fields
    // @@protoc_insertion_point(special_field:State.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a State {
    fn default() -> &'a State {
        <State as ::protobuf::Message>::default_instance()
    }
}

impl State {
    pub fn new() -> State {
        ::std::default::Default::default()
    }

    // optional string context_uri = 2;

    pub fn context_uri(&self) -> &str {
        match self.context_uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_context_uri(&mut self) {
        self.context_uri = ::std::option::Option::None;
    }

    pub fn has_context_uri(&self) -> bool {
        self.context_uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_uri(&mut self, v: ::std::string::String) {
        self.context_uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context_uri(&mut self) -> &mut ::std::string::String {
        if self.context_uri.is_none() {
            self.context_uri = ::std::option::Option::Some(::std::string::String::new());
        }
        self.context_uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_context_uri(&mut self) -> ::std::string::String {
        self.context_uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 index = 3;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional uint32 position_ms = 4;

    pub fn position_ms(&self) -> u32 {
        self.position_ms.unwrap_or(0)
    }

    pub fn clear_position_ms(&mut self) {
        self.position_ms = ::std::option::Option::None;
    }

    pub fn has_position_ms(&self) -> bool {
        self.position_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_ms(&mut self, v: u32) {
        self.position_ms = ::std::option::Option::Some(v);
    }

    // optional .PlayStatus status = 5;

    pub fn status(&self) -> PlayStatus {
        match self.status {
            Some(e) => e.enum_value_or(PlayStatus::kPlayStatusStop),
            None => PlayStatus::kPlayStatusStop,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PlayStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 position_measured_at = 7;

    pub fn position_measured_at(&self) -> u64 {
        self.position_measured_at.unwrap_or(0)
    }

    pub fn clear_position_measured_at(&mut self) {
        self.position_measured_at = ::std::option::Option::None;
    }

    pub fn has_position_measured_at(&self) -> bool {
        self.position_measured_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_measured_at(&mut self, v: u64) {
        self.position_measured_at = ::std::option::Option::Some(v);
    }

    // optional string context_description = 8;

    pub fn context_description(&self) -> &str {
        match self.context_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_context_description(&mut self) {
        self.context_description = ::std::option::Option::None;
    }

    pub fn has_context_description(&self) -> bool {
        self.context_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_description(&mut self, v: ::std::string::String) {
        self.context_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context_description(&mut self) -> &mut ::std::string::String {
        if self.context_description.is_none() {
            self.context_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.context_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_context_description(&mut self) -> ::std::string::String {
        self.context_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool shuffle = 13;

    pub fn shuffle(&self) -> bool {
        self.shuffle.unwrap_or(false)
    }

    pub fn clear_shuffle(&mut self) {
        self.shuffle = ::std::option::Option::None;
    }

    pub fn has_shuffle(&self) -> bool {
        self.shuffle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shuffle(&mut self, v: bool) {
        self.shuffle = ::std::option::Option::Some(v);
    }

    // optional bool repeat = 14;

    pub fn repeat(&self) -> bool {
        self.repeat.unwrap_or(false)
    }

    pub fn clear_repeat(&mut self) {
        self.repeat = ::std::option::Option::None;
    }

    pub fn has_repeat(&self) -> bool {
        self.repeat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeat(&mut self, v: bool) {
        self.repeat = ::std::option::Option::Some(v);
    }

    // optional string last_command_ident = 20;

    pub fn last_command_ident(&self) -> &str {
        match self.last_command_ident.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_last_command_ident(&mut self) {
        self.last_command_ident = ::std::option::Option::None;
    }

    pub fn has_last_command_ident(&self) -> bool {
        self.last_command_ident.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_command_ident(&mut self, v: ::std::string::String) {
        self.last_command_ident = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_command_ident(&mut self) -> &mut ::std::string::String {
        if self.last_command_ident.is_none() {
            self.last_command_ident = ::std::option::Option::Some(::std::string::String::new());
        }
        self.last_command_ident.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_command_ident(&mut self) -> ::std::string::String {
        self.last_command_ident.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 last_command_msgid = 21;

    pub fn last_command_msgid(&self) -> u32 {
        self.last_command_msgid.unwrap_or(0)
    }

    pub fn clear_last_command_msgid(&mut self) {
        self.last_command_msgid = ::std::option::Option::None;
    }

    pub fn has_last_command_msgid(&self) -> bool {
        self.last_command_msgid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_command_msgid(&mut self, v: u32) {
        self.last_command_msgid = ::std::option::Option::Some(v);
    }

    // optional bool playing_from_fallback = 24;

    pub fn playing_from_fallback(&self) -> bool {
        self.playing_from_fallback.unwrap_or(false)
    }

    pub fn clear_playing_from_fallback(&mut self) {
        self.playing_from_fallback = ::std::option::Option::None;
    }

    pub fn has_playing_from_fallback(&self) -> bool {
        self.playing_from_fallback.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playing_from_fallback(&mut self, v: bool) {
        self.playing_from_fallback = ::std::option::Option::Some(v);
    }

    // optional uint32 row = 25;

    pub fn row(&self) -> u32 {
        self.row.unwrap_or(0)
    }

    pub fn clear_row(&mut self) {
        self.row = ::std::option::Option::None;
    }

    pub fn has_row(&self) -> bool {
        self.row.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: u32) {
        self.row = ::std::option::Option::Some(v);
    }

    // optional uint32 playing_track_index = 26;

    pub fn playing_track_index(&self) -> u32 {
        self.playing_track_index.unwrap_or(0)
    }

    pub fn clear_playing_track_index(&mut self) {
        self.playing_track_index = ::std::option::Option::None;
    }

    pub fn has_playing_track_index(&self) -> bool {
        self.playing_track_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playing_track_index(&mut self, v: u32) {
        self.playing_track_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context_uri",
            |m: &State| { &m.context_uri },
            |m: &mut State| { &mut m.context_uri },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &State| { &m.index },
            |m: &mut State| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "position_ms",
            |m: &State| { &m.position_ms },
            |m: &mut State| { &mut m.position_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &State| { &m.status },
            |m: &mut State| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "position_measured_at",
            |m: &State| { &m.position_measured_at },
            |m: &mut State| { &mut m.position_measured_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context_description",
            |m: &State| { &m.context_description },
            |m: &mut State| { &mut m.context_description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shuffle",
            |m: &State| { &m.shuffle },
            |m: &mut State| { &mut m.shuffle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "repeat",
            |m: &State| { &m.repeat },
            |m: &mut State| { &mut m.repeat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_command_ident",
            |m: &State| { &m.last_command_ident },
            |m: &mut State| { &mut m.last_command_ident },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_command_msgid",
            |m: &State| { &m.last_command_msgid },
            |m: &mut State| { &mut m.last_command_msgid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playing_from_fallback",
            |m: &State| { &m.playing_from_fallback },
            |m: &mut State| { &mut m.playing_from_fallback },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "row",
            |m: &State| { &m.row },
            |m: &mut State| { &mut m.row },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playing_track_index",
            |m: &State| { &m.playing_track_index },
            |m: &mut State| { &mut m.playing_track_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "track",
            |m: &State| { &m.track },
            |m: &mut State| { &mut m.track },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Ad>(
            "ad",
            |m: &State| { &m.ad },
            |m: &mut State| { &mut m.ad },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<State>(
            "State",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for State {
    const NAME: &'static str = "State";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.context_uri = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.position_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.position_measured_at = ::std::option::Option::Some(is.read_uint64()?);
                },
                66 => {
                    self.context_description = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.shuffle = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.repeat = ::std::option::Option::Some(is.read_bool()?);
                },
                162 => {
                    self.last_command_ident = ::std::option::Option::Some(is.read_string()?);
                },
                168 => {
                    self.last_command_msgid = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.playing_from_fallback = ::std::option::Option::Some(is.read_bool()?);
                },
                200 => {
                    self.row = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.playing_track_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                218 => {
                    self.track.push(is.read_message()?);
                },
                226 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ad)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.context_uri.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.position_ms {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.position_measured_at {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.context_description.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.shuffle {
            my_size += 1 + 1;
        }
        if let Some(v) = self.repeat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.last_command_ident.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.last_command_msgid {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.playing_from_fallback {
            my_size += 2 + 1;
        }
        if let Some(v) = self.row {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.playing_track_index {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        for value in &self.track {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.ad.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.context_uri.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.position_ms {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.position_measured_at {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.context_description.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.shuffle {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.repeat {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.last_command_ident.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.last_command_msgid {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.playing_from_fallback {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.row {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.playing_track_index {
            os.write_uint32(26, v)?;
        }
        for v in &self.track {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        };
        if let Some(v) = self.ad.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> State {
        State::new()
    }

    fn clear(&mut self) {
        self.context_uri = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.position_ms = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.position_measured_at = ::std::option::Option::None;
        self.context_description = ::std::option::Option::None;
        self.shuffle = ::std::option::Option::None;
        self.repeat = ::std::option::Option::None;
        self.last_command_ident = ::std::option::Option::None;
        self.last_command_msgid = ::std::option::Option::None;
        self.playing_from_fallback = ::std::option::Option::None;
        self.row = ::std::option::Option::None;
        self.playing_track_index = ::std::option::Option::None;
        self.track.clear();
        self.ad.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static State {
        static instance: State = State {
            context_uri: ::std::option::Option::None,
            index: ::std::option::Option::None,
            position_ms: ::std::option::Option::None,
            status: ::std::option::Option::None,
            position_measured_at: ::std::option::Option::None,
            context_description: ::std::option::Option::None,
            shuffle: ::std::option::Option::None,
            repeat: ::std::option::Option::None,
            last_command_ident: ::std::option::Option::None,
            last_command_msgid: ::std::option::Option::None,
            playing_from_fallback: ::std::option::Option::None,
            row: ::std::option::Option::None,
            playing_track_index: ::std::option::Option::None,
            track: ::std::vec::Vec::new(),
            ad: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for State {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("State").unwrap()).clone()
    }
}

impl ::std::fmt::Display for State {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for State {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TrackRef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TrackRef {
    // message fields
    // @@protoc_insertion_point(field:TrackRef.gid)
    pub gid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:TrackRef.uri)
    pub uri: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TrackRef.queued)
    pub queued: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:TrackRef.context)
    pub context: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:TrackRef.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TrackRef {
    fn default() -> &'a TrackRef {
        <TrackRef as ::protobuf::Message>::default_instance()
    }
}

impl TrackRef {
    pub fn new() -> TrackRef {
        ::std::default::Default::default()
    }

    // optional bytes gid = 1;

    pub fn gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string uri = 2;

    pub fn uri(&self) -> &str {
        match self.uri.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_uri(&mut self) {
        self.uri = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        self.uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        if self.uri.is_none() {
            self.uri = ::std::option::Option::Some(::std::string::String::new());
        }
        self.uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        self.uri.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool queued = 3;

    pub fn queued(&self) -> bool {
        self.queued.unwrap_or(false)
    }

    pub fn clear_queued(&mut self) {
        self.queued = ::std::option::Option::None;
    }

    pub fn has_queued(&self) -> bool {
        self.queued.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queued(&mut self, v: bool) {
        self.queued = ::std::option::Option::Some(v);
    }

    // optional string context = 4;

    pub fn context(&self) -> &str {
        match self.context.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_context(&mut self) {
        self.context = ::std::option::Option::None;
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: ::std::string::String) {
        self.context = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut ::std::string::String {
        if self.context.is_none() {
            self.context = ::std::option::Option::Some(::std::string::String::new());
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> ::std::string::String {
        self.context.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &TrackRef| { &m.gid },
            |m: &mut TrackRef| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uri",
            |m: &TrackRef| { &m.uri },
            |m: &mut TrackRef| { &mut m.uri },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queued",
            |m: &TrackRef| { &m.queued },
            |m: &mut TrackRef| { &mut m.queued },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context",
            |m: &TrackRef| { &m.context },
            |m: &mut TrackRef| { &mut m.context },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrackRef>(
            "TrackRef",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TrackRef {
    const NAME: &'static str = "TrackRef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gid = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.uri = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.queued = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.context = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.uri.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.queued {
            my_size += 1 + 1;
        }
        if let Some(v) = self.context.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.uri.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.queued {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.context.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TrackRef {
        TrackRef::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.uri = ::std::option::Option::None;
        self.queued = ::std::option::Option::None;
        self.context = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TrackRef {
        static instance: TrackRef = TrackRef {
            gid: ::std::option::Option::None,
            uri: ::std::option::Option::None,
            queued: ::std::option::Option::None,
            context: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TrackRef {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TrackRef").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TrackRef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrackRef {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Ad)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Ad {
    // message fields
    // @@protoc_insertion_point(field:Ad.next)
    pub next: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:Ad.ogg_fid)
    pub ogg_fid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:Ad.image_fid)
    pub image_fid: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:Ad.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:Ad.click_url)
    pub click_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Ad.impression_url)
    pub impression_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Ad.product)
    pub product: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Ad.advertiser)
    pub advertiser: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Ad.gid)
    pub gid: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:Ad.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ad {
    fn default() -> &'a Ad {
        <Ad as ::protobuf::Message>::default_instance()
    }
}

impl Ad {
    pub fn new() -> Ad {
        ::std::default::Default::default()
    }

    // optional int32 next = 1;

    pub fn next(&self) -> i32 {
        self.next.unwrap_or(0)
    }

    pub fn clear_next(&mut self) {
        self.next = ::std::option::Option::None;
    }

    pub fn has_next(&self) -> bool {
        self.next.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next(&mut self, v: i32) {
        self.next = ::std::option::Option::Some(v);
    }

    // optional bytes ogg_fid = 2;

    pub fn ogg_fid(&self) -> &[u8] {
        match self.ogg_fid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ogg_fid(&mut self) {
        self.ogg_fid = ::std::option::Option::None;
    }

    pub fn has_ogg_fid(&self) -> bool {
        self.ogg_fid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ogg_fid(&mut self, v: ::std::vec::Vec<u8>) {
        self.ogg_fid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ogg_fid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ogg_fid.is_none() {
            self.ogg_fid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ogg_fid.as_mut().unwrap()
    }

    // Take field
    pub fn take_ogg_fid(&mut self) -> ::std::vec::Vec<u8> {
        self.ogg_fid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes image_fid = 3;

    pub fn image_fid(&self) -> &[u8] {
        match self.image_fid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_image_fid(&mut self) {
        self.image_fid = ::std::option::Option::None;
    }

    pub fn has_image_fid(&self) -> bool {
        self.image_fid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_fid(&mut self, v: ::std::vec::Vec<u8>) {
        self.image_fid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_fid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.image_fid.is_none() {
            self.image_fid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.image_fid.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_fid(&mut self) -> ::std::vec::Vec<u8> {
        self.image_fid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 duration = 4;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional string click_url = 5;

    pub fn click_url(&self) -> &str {
        match self.click_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_click_url(&mut self) {
        self.click_url = ::std::option::Option::None;
    }

    pub fn has_click_url(&self) -> bool {
        self.click_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_click_url(&mut self, v: ::std::string::String) {
        self.click_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_click_url(&mut self) -> &mut ::std::string::String {
        if self.click_url.is_none() {
            self.click_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.click_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_click_url(&mut self) -> ::std::string::String {
        self.click_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string impression_url = 6;

    pub fn impression_url(&self) -> &str {
        match self.impression_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_impression_url(&mut self) {
        self.impression_url = ::std::option::Option::None;
    }

    pub fn has_impression_url(&self) -> bool {
        self.impression_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_impression_url(&mut self, v: ::std::string::String) {
        self.impression_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_impression_url(&mut self) -> &mut ::std::string::String {
        if self.impression_url.is_none() {
            self.impression_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.impression_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_impression_url(&mut self) -> ::std::string::String {
        self.impression_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string product = 7;

    pub fn product(&self) -> &str {
        match self.product.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product(&mut self) {
        self.product = ::std::option::Option::None;
    }

    pub fn has_product(&self) -> bool {
        self.product.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product(&mut self, v: ::std::string::String) {
        self.product = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product(&mut self) -> &mut ::std::string::String {
        if self.product.is_none() {
            self.product = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product.as_mut().unwrap()
    }

    // Take field
    pub fn take_product(&mut self) -> ::std::string::String {
        self.product.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string advertiser = 8;

    pub fn advertiser(&self) -> &str {
        match self.advertiser.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_advertiser(&mut self) {
        self.advertiser = ::std::option::Option::None;
    }

    pub fn has_advertiser(&self) -> bool {
        self.advertiser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_advertiser(&mut self, v: ::std::string::String) {
        self.advertiser = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_advertiser(&mut self) -> &mut ::std::string::String {
        if self.advertiser.is_none() {
            self.advertiser = ::std::option::Option::Some(::std::string::String::new());
        }
        self.advertiser.as_mut().unwrap()
    }

    // Take field
    pub fn take_advertiser(&mut self) -> ::std::string::String {
        self.advertiser.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes gid = 9;

    pub fn gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "next",
            |m: &Ad| { &m.next },
            |m: &mut Ad| { &mut m.next },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ogg_fid",
            |m: &Ad| { &m.ogg_fid },
            |m: &mut Ad| { &mut m.ogg_fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image_fid",
            |m: &Ad| { &m.image_fid },
            |m: &mut Ad| { &mut m.image_fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &Ad| { &m.duration },
            |m: &mut Ad| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "click_url",
            |m: &Ad| { &m.click_url },
            |m: &mut Ad| { &mut m.click_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "impression_url",
            |m: &Ad| { &m.impression_url },
            |m: &mut Ad| { &mut m.impression_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "product",
            |m: &Ad| { &m.product },
            |m: &mut Ad| { &mut m.product },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "advertiser",
            |m: &Ad| { &m.advertiser },
            |m: &mut Ad| { &mut m.advertiser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &Ad| { &m.gid },
            |m: &mut Ad| { &mut m.gid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ad>(
            "Ad",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ad {
    const NAME: &'static str = "Ad";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.next = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.ogg_fid = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.image_fid = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.click_url = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.impression_url = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.product = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.advertiser = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.gid = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.next {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.ogg_fid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.image_fid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.click_url.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.impression_url.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.product.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.advertiser.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.next {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ogg_fid.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.image_fid.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.click_url.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.impression_url.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.product.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.advertiser.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.gid.as_ref() {
            os.write_bytes(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ad {
        Ad::new()
    }

    fn clear(&mut self) {
        self.next = ::std::option::Option::None;
        self.ogg_fid = ::std::option::Option::None;
        self.image_fid = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.click_url = ::std::option::Option::None;
        self.impression_url = ::std::option::Option::None;
        self.product = ::std::option::Option::None;
        self.advertiser = ::std::option::Option::None;
        self.gid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ad {
        static instance: Ad = Ad {
            next: ::std::option::Option::None,
            ogg_fid: ::std::option::Option::None,
            image_fid: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            click_url: ::std::option::Option::None,
            impression_url: ::std::option::Option::None,
            product: ::std::option::Option::None,
            advertiser: ::std::option::Option::None,
            gid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ad {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ad").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ad {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Metadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Metadata {
    // message fields
    // @@protoc_insertion_point(field:Metadata.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:Metadata.metadata)
    pub metadata: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:Metadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Metadata {
    fn default() -> &'a Metadata {
        <Metadata as ::protobuf::Message>::default_instance()
    }
}

impl Metadata {
    pub fn new() -> Metadata {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string metadata = 2;

    pub fn metadata(&self) -> &str {
        match self.metadata.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        if self.metadata.is_none() {
            self.metadata = ::std::option::Option::Some(::std::string::String::new());
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        self.metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &Metadata| { &m.type_ },
            |m: &mut Metadata| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "metadata",
            |m: &Metadata| { &m.metadata },
            |m: &mut Metadata| { &mut m.metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Metadata>(
            "Metadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Metadata {
    const NAME: &'static str = "Metadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.metadata = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.metadata.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Metadata {
        Metadata::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Metadata {
        static instance: Metadata = Metadata {
            type_: ::std::option::Option::None,
            metadata: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Metadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Metadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Metadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MessageType)
pub enum MessageType {
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeHello)
    kMessageTypeHello = 1,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeGoodbye)
    kMessageTypeGoodbye = 2,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeProbe)
    kMessageTypeProbe = 3,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeNotify)
    kMessageTypeNotify = 10,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeLoad)
    kMessageTypeLoad = 20,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypePlay)
    kMessageTypePlay = 21,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypePause)
    kMessageTypePause = 22,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypePlayPause)
    kMessageTypePlayPause = 23,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeSeek)
    kMessageTypeSeek = 24,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypePrev)
    kMessageTypePrev = 25,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeNext)
    kMessageTypeNext = 26,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeVolume)
    kMessageTypeVolume = 27,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeShuffle)
    kMessageTypeShuffle = 28,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeRepeat)
    kMessageTypeRepeat = 29,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeVolumeDown)
    kMessageTypeVolumeDown = 31,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeVolumeUp)
    kMessageTypeVolumeUp = 32,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeReplace)
    kMessageTypeReplace = 33,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeLogout)
    kMessageTypeLogout = 34,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeAction)
    kMessageTypeAction = 35,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeRename)
    kMessageTypeRename = 36,
    // @@protoc_insertion_point(enum_value:MessageType.kMessageTypeUpdateMetadata)
    kMessageTypeUpdateMetadata = 128,
}

impl ::protobuf::Enum for MessageType {
    const NAME: &'static str = "MessageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageType> {
        match value {
            1 => ::std::option::Option::Some(MessageType::kMessageTypeHello),
            2 => ::std::option::Option::Some(MessageType::kMessageTypeGoodbye),
            3 => ::std::option::Option::Some(MessageType::kMessageTypeProbe),
            10 => ::std::option::Option::Some(MessageType::kMessageTypeNotify),
            20 => ::std::option::Option::Some(MessageType::kMessageTypeLoad),
            21 => ::std::option::Option::Some(MessageType::kMessageTypePlay),
            22 => ::std::option::Option::Some(MessageType::kMessageTypePause),
            23 => ::std::option::Option::Some(MessageType::kMessageTypePlayPause),
            24 => ::std::option::Option::Some(MessageType::kMessageTypeSeek),
            25 => ::std::option::Option::Some(MessageType::kMessageTypePrev),
            26 => ::std::option::Option::Some(MessageType::kMessageTypeNext),
            27 => ::std::option::Option::Some(MessageType::kMessageTypeVolume),
            28 => ::std::option::Option::Some(MessageType::kMessageTypeShuffle),
            29 => ::std::option::Option::Some(MessageType::kMessageTypeRepeat),
            31 => ::std::option::Option::Some(MessageType::kMessageTypeVolumeDown),
            32 => ::std::option::Option::Some(MessageType::kMessageTypeVolumeUp),
            33 => ::std::option::Option::Some(MessageType::kMessageTypeReplace),
            34 => ::std::option::Option::Some(MessageType::kMessageTypeLogout),
            35 => ::std::option::Option::Some(MessageType::kMessageTypeAction),
            36 => ::std::option::Option::Some(MessageType::kMessageTypeRename),
            128 => ::std::option::Option::Some(MessageType::kMessageTypeUpdateMetadata),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MessageType> {
        match str {
            "kMessageTypeHello" => ::std::option::Option::Some(MessageType::kMessageTypeHello),
            "kMessageTypeGoodbye" => ::std::option::Option::Some(MessageType::kMessageTypeGoodbye),
            "kMessageTypeProbe" => ::std::option::Option::Some(MessageType::kMessageTypeProbe),
            "kMessageTypeNotify" => ::std::option::Option::Some(MessageType::kMessageTypeNotify),
            "kMessageTypeLoad" => ::std::option::Option::Some(MessageType::kMessageTypeLoad),
            "kMessageTypePlay" => ::std::option::Option::Some(MessageType::kMessageTypePlay),
            "kMessageTypePause" => ::std::option::Option::Some(MessageType::kMessageTypePause),
            "kMessageTypePlayPause" => ::std::option::Option::Some(MessageType::kMessageTypePlayPause),
            "kMessageTypeSeek" => ::std::option::Option::Some(MessageType::kMessageTypeSeek),
            "kMessageTypePrev" => ::std::option::Option::Some(MessageType::kMessageTypePrev),
            "kMessageTypeNext" => ::std::option::Option::Some(MessageType::kMessageTypeNext),
            "kMessageTypeVolume" => ::std::option::Option::Some(MessageType::kMessageTypeVolume),
            "kMessageTypeShuffle" => ::std::option::Option::Some(MessageType::kMessageTypeShuffle),
            "kMessageTypeRepeat" => ::std::option::Option::Some(MessageType::kMessageTypeRepeat),
            "kMessageTypeVolumeDown" => ::std::option::Option::Some(MessageType::kMessageTypeVolumeDown),
            "kMessageTypeVolumeUp" => ::std::option::Option::Some(MessageType::kMessageTypeVolumeUp),
            "kMessageTypeReplace" => ::std::option::Option::Some(MessageType::kMessageTypeReplace),
            "kMessageTypeLogout" => ::std::option::Option::Some(MessageType::kMessageTypeLogout),
            "kMessageTypeAction" => ::std::option::Option::Some(MessageType::kMessageTypeAction),
            "kMessageTypeRename" => ::std::option::Option::Some(MessageType::kMessageTypeRename),
            "kMessageTypeUpdateMetadata" => ::std::option::Option::Some(MessageType::kMessageTypeUpdateMetadata),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MessageType] = &[
        MessageType::kMessageTypeHello,
        MessageType::kMessageTypeGoodbye,
        MessageType::kMessageTypeProbe,
        MessageType::kMessageTypeNotify,
        MessageType::kMessageTypeLoad,
        MessageType::kMessageTypePlay,
        MessageType::kMessageTypePause,
        MessageType::kMessageTypePlayPause,
        MessageType::kMessageTypeSeek,
        MessageType::kMessageTypePrev,
        MessageType::kMessageTypeNext,
        MessageType::kMessageTypeVolume,
        MessageType::kMessageTypeShuffle,
        MessageType::kMessageTypeRepeat,
        MessageType::kMessageTypeVolumeDown,
        MessageType::kMessageTypeVolumeUp,
        MessageType::kMessageTypeReplace,
        MessageType::kMessageTypeLogout,
        MessageType::kMessageTypeAction,
        MessageType::kMessageTypeRename,
        MessageType::kMessageTypeUpdateMetadata,
    ];
}

impl ::protobuf::EnumFull for MessageType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MessageType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MessageType::kMessageTypeHello => 0,
            MessageType::kMessageTypeGoodbye => 1,
            MessageType::kMessageTypeProbe => 2,
            MessageType::kMessageTypeNotify => 3,
            MessageType::kMessageTypeLoad => 4,
            MessageType::kMessageTypePlay => 5,
            MessageType::kMessageTypePause => 6,
            MessageType::kMessageTypePlayPause => 7,
            MessageType::kMessageTypeSeek => 8,
            MessageType::kMessageTypePrev => 9,
            MessageType::kMessageTypeNext => 10,
            MessageType::kMessageTypeVolume => 11,
            MessageType::kMessageTypeShuffle => 12,
            MessageType::kMessageTypeRepeat => 13,
            MessageType::kMessageTypeVolumeDown => 14,
            MessageType::kMessageTypeVolumeUp => 15,
            MessageType::kMessageTypeReplace => 16,
            MessageType::kMessageTypeLogout => 17,
            MessageType::kMessageTypeAction => 18,
            MessageType::kMessageTypeRename => 19,
            MessageType::kMessageTypeUpdateMetadata => 20,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for MessageType {
    fn default() -> Self {
        MessageType::kMessageTypeHello
    }
}

impl MessageType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MessageType>("MessageType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CapabilityType)
pub enum CapabilityType {
    // @@protoc_insertion_point(enum_value:CapabilityType.kSupportedContexts)
    kSupportedContexts = 1,
    // @@protoc_insertion_point(enum_value:CapabilityType.kCanBePlayer)
    kCanBePlayer = 2,
    // @@protoc_insertion_point(enum_value:CapabilityType.kRestrictToLocal)
    kRestrictToLocal = 3,
    // @@protoc_insertion_point(enum_value:CapabilityType.kDeviceType)
    kDeviceType = 4,
    // @@protoc_insertion_point(enum_value:CapabilityType.kGaiaEqConnectId)
    kGaiaEqConnectId = 5,
    // @@protoc_insertion_point(enum_value:CapabilityType.kSupportsLogout)
    kSupportsLogout = 6,
    // @@protoc_insertion_point(enum_value:CapabilityType.kIsObservable)
    kIsObservable = 7,
    // @@protoc_insertion_point(enum_value:CapabilityType.kVolumeSteps)
    kVolumeSteps = 8,
    // @@protoc_insertion_point(enum_value:CapabilityType.kSupportedTypes)
    kSupportedTypes = 9,
    // @@protoc_insertion_point(enum_value:CapabilityType.kCommandAcks)
    kCommandAcks = 10,
    // @@protoc_insertion_point(enum_value:CapabilityType.kSupportsRename)
    kSupportsRename = 11,
    // @@protoc_insertion_point(enum_value:CapabilityType.kHidden)
    kHidden = 12,
    // @@protoc_insertion_point(enum_value:CapabilityType.kSupportsPlaylistV2)
    kSupportsPlaylistV2 = 13,
    // @@protoc_insertion_point(enum_value:CapabilityType.kSupportsExternalEpisodes)
    kSupportsExternalEpisodes = 14,
}

impl ::protobuf::Enum for CapabilityType {
    const NAME: &'static str = "CapabilityType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CapabilityType> {
        match value {
            1 => ::std::option::Option::Some(CapabilityType::kSupportedContexts),
            2 => ::std::option::Option::Some(CapabilityType::kCanBePlayer),
            3 => ::std::option::Option::Some(CapabilityType::kRestrictToLocal),
            4 => ::std::option::Option::Some(CapabilityType::kDeviceType),
            5 => ::std::option::Option::Some(CapabilityType::kGaiaEqConnectId),
            6 => ::std::option::Option::Some(CapabilityType::kSupportsLogout),
            7 => ::std::option::Option::Some(CapabilityType::kIsObservable),
            8 => ::std::option::Option::Some(CapabilityType::kVolumeSteps),
            9 => ::std::option::Option::Some(CapabilityType::kSupportedTypes),
            10 => ::std::option::Option::Some(CapabilityType::kCommandAcks),
            11 => ::std::option::Option::Some(CapabilityType::kSupportsRename),
            12 => ::std::option::Option::Some(CapabilityType::kHidden),
            13 => ::std::option::Option::Some(CapabilityType::kSupportsPlaylistV2),
            14 => ::std::option::Option::Some(CapabilityType::kSupportsExternalEpisodes),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CapabilityType> {
        match str {
            "kSupportedContexts" => ::std::option::Option::Some(CapabilityType::kSupportedContexts),
            "kCanBePlayer" => ::std::option::Option::Some(CapabilityType::kCanBePlayer),
            "kRestrictToLocal" => ::std::option::Option::Some(CapabilityType::kRestrictToLocal),
            "kDeviceType" => ::std::option::Option::Some(CapabilityType::kDeviceType),
            "kGaiaEqConnectId" => ::std::option::Option::Some(CapabilityType::kGaiaEqConnectId),
            "kSupportsLogout" => ::std::option::Option::Some(CapabilityType::kSupportsLogout),
            "kIsObservable" => ::std::option::Option::Some(CapabilityType::kIsObservable),
            "kVolumeSteps" => ::std::option::Option::Some(CapabilityType::kVolumeSteps),
            "kSupportedTypes" => ::std::option::Option::Some(CapabilityType::kSupportedTypes),
            "kCommandAcks" => ::std::option::Option::Some(CapabilityType::kCommandAcks),
            "kSupportsRename" => ::std::option::Option::Some(CapabilityType::kSupportsRename),
            "kHidden" => ::std::option::Option::Some(CapabilityType::kHidden),
            "kSupportsPlaylistV2" => ::std::option::Option::Some(CapabilityType::kSupportsPlaylistV2),
            "kSupportsExternalEpisodes" => ::std::option::Option::Some(CapabilityType::kSupportsExternalEpisodes),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CapabilityType] = &[
        CapabilityType::kSupportedContexts,
        CapabilityType::kCanBePlayer,
        CapabilityType::kRestrictToLocal,
        CapabilityType::kDeviceType,
        CapabilityType::kGaiaEqConnectId,
        CapabilityType::kSupportsLogout,
        CapabilityType::kIsObservable,
        CapabilityType::kVolumeSteps,
        CapabilityType::kSupportedTypes,
        CapabilityType::kCommandAcks,
        CapabilityType::kSupportsRename,
        CapabilityType::kHidden,
        CapabilityType::kSupportsPlaylistV2,
        CapabilityType::kSupportsExternalEpisodes,
    ];
}

impl ::protobuf::EnumFull for CapabilityType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CapabilityType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CapabilityType::kSupportedContexts => 0,
            CapabilityType::kCanBePlayer => 1,
            CapabilityType::kRestrictToLocal => 2,
            CapabilityType::kDeviceType => 3,
            CapabilityType::kGaiaEqConnectId => 4,
            CapabilityType::kSupportsLogout => 5,
            CapabilityType::kIsObservable => 6,
            CapabilityType::kVolumeSteps => 7,
            CapabilityType::kSupportedTypes => 8,
            CapabilityType::kCommandAcks => 9,
            CapabilityType::kSupportsRename => 10,
            CapabilityType::kHidden => 11,
            CapabilityType::kSupportsPlaylistV2 => 12,
            CapabilityType::kSupportsExternalEpisodes => 13,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CapabilityType {
    fn default() -> Self {
        CapabilityType::kSupportedContexts
    }
}

impl CapabilityType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CapabilityType>("CapabilityType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PlayStatus)
pub enum PlayStatus {
    // @@protoc_insertion_point(enum_value:PlayStatus.kPlayStatusStop)
    kPlayStatusStop = 0,
    // @@protoc_insertion_point(enum_value:PlayStatus.kPlayStatusPlay)
    kPlayStatusPlay = 1,
    // @@protoc_insertion_point(enum_value:PlayStatus.kPlayStatusPause)
    kPlayStatusPause = 2,
    // @@protoc_insertion_point(enum_value:PlayStatus.kPlayStatusLoading)
    kPlayStatusLoading = 3,
}

impl ::protobuf::Enum for PlayStatus {
    const NAME: &'static str = "PlayStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PlayStatus> {
        match value {
            0 => ::std::option::Option::Some(PlayStatus::kPlayStatusStop),
            1 => ::std::option::Option::Some(PlayStatus::kPlayStatusPlay),
            2 => ::std::option::Option::Some(PlayStatus::kPlayStatusPause),
            3 => ::std::option::Option::Some(PlayStatus::kPlayStatusLoading),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PlayStatus> {
        match str {
            "kPlayStatusStop" => ::std::option::Option::Some(PlayStatus::kPlayStatusStop),
            "kPlayStatusPlay" => ::std::option::Option::Some(PlayStatus::kPlayStatusPlay),
            "kPlayStatusPause" => ::std::option::Option::Some(PlayStatus::kPlayStatusPause),
            "kPlayStatusLoading" => ::std::option::Option::Some(PlayStatus::kPlayStatusLoading),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PlayStatus] = &[
        PlayStatus::kPlayStatusStop,
        PlayStatus::kPlayStatusPlay,
        PlayStatus::kPlayStatusPause,
        PlayStatus::kPlayStatusLoading,
    ];
}

impl ::protobuf::EnumFull for PlayStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PlayStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PlayStatus {
    fn default() -> Self {
        PlayStatus::kPlayStatusStop
    }
}

impl PlayStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PlayStatus>("PlayStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bspirc.proto\"\xfa\x03\n\x05Frame\x12\x18\n\x07version\x18\x01\x20\
    \x01(\rR\x07version\x12\x14\n\x05ident\x18\x02\x20\x01(\tR\x05ident\x12)\
    \n\x10protocol_version\x18\x03\x20\x01(\tR\x0fprotocolVersion\x12\x15\n\
    \x06seq_nr\x18\x04\x20\x01(\rR\x05seqNr\x12\x1e\n\x03typ\x18\x05\x20\x01\
    (\x0e2\x0c.MessageTypeR\x03typ\x12/\n\x0cdevice_state\x18\x07\x20\x01(\
    \x0b2\x0c.DeviceStateR\x0bdeviceState\x12\"\n\x07goodbye\x18\x0b\x20\x01\
    (\x0b2\x08.GoodbyeR\x07goodbye\x12\x1c\n\x05state\x18\x0c\x20\x01(\x0b2\
    \x06.StateR\x05state\x12\x1a\n\x08position\x18\r\x20\x01(\rR\x08position\
    \x12\x16\n\x06volume\x18\x0e\x20\x01(\rR\x06volume\x12&\n\x0fstate_updat\
    e_id\x18\x11\x20\x01(\x03R\rstateUpdateId\x12\x1c\n\trecipient\x18\x12\
    \x20\x03(\tR\trecipient\x120\n\x14context_player_state\x18\x13\x20\x01(\
    \x0cR\x12contextPlayerState\x12\x19\n\x08new_name\x18\x14\x20\x01(\tR\
    \x07newName\x12%\n\x08metadata\x18\x19\x20\x01(\x0b2\t.MetadataR\x08meta\
    data\"\x88\x03\n\x0bDeviceState\x12\x1d\n\nsw_version\x18\x01\x20\x01(\t\
    R\tswVersion\x12\x1b\n\tis_active\x18\n\x20\x01(\x08R\x08isActive\x12\
    \x19\n\x08can_play\x18\x0b\x20\x01(\x08R\x07canPlay\x12\x16\n\x06volume\
    \x18\x0c\x20\x01(\rR\x06volume\x12\x12\n\x04name\x18\r\x20\x01(\tR\x04na\
    me\x12\x1d\n\nerror_code\x18\x0e\x20\x01(\rR\terrorCode\x12(\n\x10became\
    _active_at\x18\x0f\x20\x01(\x03R\x0ebecameActiveAt\x12#\n\rerror_message\
    \x18\x10\x20\x01(\tR\x0cerrorMessage\x12/\n\x0ccapabilities\x18\x11\x20\
    \x03(\x0b2\x0b.CapabilityR\x0ccapabilities\x120\n\x14context_player_erro\
    r\x18\x14\x20\x01(\tR\x12contextPlayerError\x12%\n\x08metadata\x18\x19\
    \x20\x03(\x0b2\t.MetadataR\x08metadata\"m\n\nCapability\x12!\n\x03typ\
    \x18\x01\x20\x01(\x0e2\x0f.CapabilityTypeR\x03typ\x12\x1a\n\x08intValue\
    \x18\x02\x20\x03(\x03R\x08intValue\x12\x20\n\x0bstringValue\x18\x03\x20\
    \x03(\tR\x0bstringValue\"!\n\x07Goodbye\x12\x16\n\x06reason\x18\x01\x20\
    \x01(\tR\x06reason\"\xa1\x04\n\x05State\x12\x1f\n\x0bcontext_uri\x18\x02\
    \x20\x01(\tR\ncontextUri\x12\x14\n\x05index\x18\x03\x20\x01(\rR\x05index\
    \x12\x1f\n\x0bposition_ms\x18\x04\x20\x01(\rR\npositionMs\x12#\n\x06stat\
    us\x18\x05\x20\x01(\x0e2\x0b.PlayStatusR\x06status\x120\n\x14position_me\
    asured_at\x18\x07\x20\x01(\x04R\x12positionMeasuredAt\x12/\n\x13context_\
    description\x18\x08\x20\x01(\tR\x12contextDescription\x12\x18\n\x07shuff\
    le\x18\r\x20\x01(\x08R\x07shuffle\x12\x16\n\x06repeat\x18\x0e\x20\x01(\
    \x08R\x06repeat\x12,\n\x12last_command_ident\x18\x14\x20\x01(\tR\x10last\
    CommandIdent\x12,\n\x12last_command_msgid\x18\x15\x20\x01(\rR\x10lastCom\
    mandMsgid\x122\n\x15playing_from_fallback\x18\x18\x20\x01(\x08R\x13playi\
    ngFromFallback\x12\x10\n\x03row\x18\x19\x20\x01(\rR\x03row\x12.\n\x13pla\
    ying_track_index\x18\x1a\x20\x01(\rR\x11playingTrackIndex\x12\x1f\n\x05t\
    rack\x18\x1b\x20\x03(\x0b2\t.TrackRefR\x05track\x12\x13\n\x02ad\x18\x1c\
    \x20\x01(\x0b2\x03.AdR\x02ad\"`\n\x08TrackRef\x12\x10\n\x03gid\x18\x01\
    \x20\x01(\x0cR\x03gid\x12\x10\n\x03uri\x18\x02\x20\x01(\tR\x03uri\x12\
    \x16\n\x06queued\x18\x03\x20\x01(\x08R\x06queued\x12\x18\n\x07context\
    \x18\x04\x20\x01(\tR\x07context\"\xfa\x01\n\x02Ad\x12\x12\n\x04next\x18\
    \x01\x20\x01(\x05R\x04next\x12\x17\n\x07ogg_fid\x18\x02\x20\x01(\x0cR\
    \x06oggFid\x12\x1b\n\timage_fid\x18\x03\x20\x01(\x0cR\x08imageFid\x12\
    \x1a\n\x08duration\x18\x04\x20\x01(\x05R\x08duration\x12\x1b\n\tclick_ur\
    l\x18\x05\x20\x01(\tR\x08clickUrl\x12%\n\x0eimpression_url\x18\x06\x20\
    \x01(\tR\rimpressionUrl\x12\x18\n\x07product\x18\x07\x20\x01(\tR\x07prod\
    uct\x12\x1e\n\nadvertiser\x18\x08\x20\x01(\tR\nadvertiser\x12\x10\n\x03g\
    id\x18\t\x20\x01(\x0cR\x03gid\":\n\x08Metadata\x12\x12\n\x04type\x18\x01\
    \x20\x01(\tR\x04type\x12\x1a\n\x08metadata\x18\x02\x20\x01(\tR\x08metada\
    ta*\x8d\x04\n\x0bMessageType\x12\x15\n\x11kMessageTypeHello\x10\x01\x12\
    \x17\n\x13kMessageTypeGoodbye\x10\x02\x12\x15\n\x11kMessageTypeProbe\x10\
    \x03\x12\x16\n\x12kMessageTypeNotify\x10\n\x12\x14\n\x10kMessageTypeLoad\
    \x10\x14\x12\x14\n\x10kMessageTypePlay\x10\x15\x12\x15\n\x11kMessageType\
    Pause\x10\x16\x12\x19\n\x15kMessageTypePlayPause\x10\x17\x12\x14\n\x10kM\
    essageTypeSeek\x10\x18\x12\x14\n\x10kMessageTypePrev\x10\x19\x12\x14\n\
    \x10kMessageTypeNext\x10\x1a\x12\x16\n\x12kMessageTypeVolume\x10\x1b\x12\
    \x17\n\x13kMessageTypeShuffle\x10\x1c\x12\x16\n\x12kMessageTypeRepeat\
    \x10\x1d\x12\x1a\n\x16kMessageTypeVolumeDown\x10\x1f\x12\x18\n\x14kMessa\
    geTypeVolumeUp\x10\x20\x12\x17\n\x13kMessageTypeReplace\x10!\x12\x16\n\
    \x12kMessageTypeLogout\x10\"\x12\x16\n\x12kMessageTypeAction\x10#\x12\
    \x16\n\x12kMessageTypeRename\x10$\x12\x1f\n\x1akMessageTypeUpdateMetadat\
    a\x10\x80\x01*\xb2\x02\n\x0eCapabilityType\x12\x16\n\x12kSupportedContex\
    ts\x10\x01\x12\x10\n\x0ckCanBePlayer\x10\x02\x12\x14\n\x10kRestrictToLoc\
    al\x10\x03\x12\x0f\n\x0bkDeviceType\x10\x04\x12\x14\n\x10kGaiaEqConnectI\
    d\x10\x05\x12\x13\n\x0fkSupportsLogout\x10\x06\x12\x11\n\rkIsObservable\
    \x10\x07\x12\x10\n\x0ckVolumeSteps\x10\x08\x12\x13\n\x0fkSupportedTypes\
    \x10\t\x12\x10\n\x0ckCommandAcks\x10\n\x12\x13\n\x0fkSupportsRename\x10\
    \x0b\x12\x0b\n\x07kHidden\x10\x0c\x12\x17\n\x13kSupportsPlaylistV2\x10\r\
    \x12\x1d\n\x19kSupportsExternalEpisodes\x10\x0e*d\n\nPlayStatus\x12\x13\
    \n\x0fkPlayStatusStop\x10\0\x12\x13\n\x0fkPlayStatusPlay\x10\x01\x12\x14\
    \n\x10kPlayStatusPause\x10\x02\x12\x16\n\x12kPlayStatusLoading\x10\x03b\
    \x06proto2\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(8);
            messages.push(Frame::generated_message_descriptor_data());
            messages.push(DeviceState::generated_message_descriptor_data());
            messages.push(Capability::generated_message_descriptor_data());
            messages.push(Goodbye::generated_message_descriptor_data());
            messages.push(State::generated_message_descriptor_data());
            messages.push(TrackRef::generated_message_descriptor_data());
            messages.push(Ad::generated_message_descriptor_data());
            messages.push(Metadata::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(MessageType::generated_enum_descriptor_data());
            enums.push(CapabilityType::generated_enum_descriptor_data());
            enums.push(PlayStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
